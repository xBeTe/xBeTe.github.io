<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>比特币 | XzXie&#39;s docs</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="notes, blogs, share">
    
    <link rel="preload" href="/assets/css/0.styles.9f84806b.css" as="style"><link rel="preload" href="/assets/js/app.d06c6709.js" as="script"><link rel="preload" href="/assets/js/2.58244656.js" as="script"><link rel="preload" href="/assets/js/1.6ba70183.js" as="script"><link rel="preload" href="/assets/js/24.f6864778.js" as="script"><link rel="prefetch" href="/assets/js/10.0720960b.js"><link rel="prefetch" href="/assets/js/11.2a97faa3.js"><link rel="prefetch" href="/assets/js/12.6b9ed61d.js"><link rel="prefetch" href="/assets/js/13.ebfb1f42.js"><link rel="prefetch" href="/assets/js/14.3e65117c.js"><link rel="prefetch" href="/assets/js/15.2d87bde7.js"><link rel="prefetch" href="/assets/js/16.9ca9aae8.js"><link rel="prefetch" href="/assets/js/17.3dbcb51f.js"><link rel="prefetch" href="/assets/js/18.4c170722.js"><link rel="prefetch" href="/assets/js/19.d8afd0ae.js"><link rel="prefetch" href="/assets/js/20.10e47ab9.js"><link rel="prefetch" href="/assets/js/21.0ad1d6a3.js"><link rel="prefetch" href="/assets/js/22.b7c97fbe.js"><link rel="prefetch" href="/assets/js/23.4d1da05b.js"><link rel="prefetch" href="/assets/js/25.75176990.js"><link rel="prefetch" href="/assets/js/26.59fe80a5.js"><link rel="prefetch" href="/assets/js/27.a811c9bb.js"><link rel="prefetch" href="/assets/js/28.6b59eb8d.js"><link rel="prefetch" href="/assets/js/29.f41b1a18.js"><link rel="prefetch" href="/assets/js/3.bc6bba9e.js"><link rel="prefetch" href="/assets/js/30.487fc7a2.js"><link rel="prefetch" href="/assets/js/31.3548df4f.js"><link rel="prefetch" href="/assets/js/32.a77f1645.js"><link rel="prefetch" href="/assets/js/33.0d7de458.js"><link rel="prefetch" href="/assets/js/34.c598fd10.js"><link rel="prefetch" href="/assets/js/35.79c21276.js"><link rel="prefetch" href="/assets/js/36.1454edc2.js"><link rel="prefetch" href="/assets/js/37.ca307149.js"><link rel="prefetch" href="/assets/js/38.7119b7a7.js"><link rel="prefetch" href="/assets/js/39.93ec7e0b.js"><link rel="prefetch" href="/assets/js/4.45665f8a.js"><link rel="prefetch" href="/assets/js/40.fd10051f.js"><link rel="prefetch" href="/assets/js/5.7098d77a.js"><link rel="prefetch" href="/assets/js/6.0c0a0f39.js"><link rel="prefetch" href="/assets/js/7.6a854e57.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5e19b665.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9f84806b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/img/logo.png" alt="XzXie's docs" class="logo"> <span class="site-name can-hide">XzXie's docs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="区块链" class="dropdown-title"><span class="title">区块链</span> <span class="arrow down"></span></button> <button type="button" aria-label="区块链" class="mobile-dropdown-title"><span class="title">区块链</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blockchain/BTC/比特币与区块链.html" class="nav-link">
  比特币
</a></li><li class="dropdown-item"><!----> <a href="/blockchain/ETH/部署以太坊私链.html" class="nav-link">
  以太坊
</a></li><li class="dropdown-item"><!----> <a href="/blockchain/Fabric/1_部署 Fabric 生产网络.html" class="nav-link">
  Fabric
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front-end/Vue/Vue2.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/front-end/VuePress/VuePress项目部署.html" class="nav-link">
  VuePress
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/xBeTe" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="区块链" class="dropdown-title"><span class="title">区块链</span> <span class="arrow down"></span></button> <button type="button" aria-label="区块链" class="mobile-dropdown-title"><span class="title">区块链</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blockchain/BTC/比特币与区块链.html" class="nav-link">
  比特币
</a></li><li class="dropdown-item"><!----> <a href="/blockchain/ETH/部署以太坊私链.html" class="nav-link">
  以太坊
</a></li><li class="dropdown-item"><!----> <a href="/blockchain/Fabric/1_部署 Fabric 生产网络.html" class="nav-link">
  Fabric
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front-end/Vue/Vue2.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/front-end/VuePress/VuePress项目部署.html" class="nav-link">
  VuePress
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/xBeTe" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/about.html" class="sidebar-link">关于</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/blockchain/" class="sidebar-heading clickable router-link-active open"><span>区块链</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>比特币</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blockchain/BTC/比特币与区块链.html" class="active sidebar-link">比特币</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#密码学原理" class="sidebar-link">密码学原理</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#数据结构" class="sidebar-link">数据结构</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#btc-协议" class="sidebar-link">BTC 协议</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#btc-实现" class="sidebar-link">BTC 实现</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#btc-网络" class="sidebar-link">BTC 网络</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#btc挖矿难度" class="sidebar-link">BTC挖矿难度</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#btc-挖矿" class="sidebar-link">BTC 挖矿</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#btc-脚本" class="sidebar-link">BTC 脚本</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#btc-分叉" class="sidebar-link">BTC 分叉</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#问答" class="sidebar-link">问答</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#btc-匿名性" class="sidebar-link">BTC 匿名性</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#btc-思考" class="sidebar-link">BTC 思考</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#eth-概述" class="sidebar-link">ETH 概述</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#eth-账户" class="sidebar-link">ETH 账户</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#eth-状态树" class="sidebar-link">ETH 状态树</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#eth-交易树和收据树" class="sidebar-link">ETH 交易树和收据树</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#eth-ghost协议" class="sidebar-link">ETH GHOST协议</a></li><li class="sidebar-sub-header"><a href="/blockchain/BTC/比特币与区块链.html#eth-挖矿算法" class="sidebar-link">ETH 挖矿算法</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>以太坊</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Fabric</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/front-end/" class="sidebar-heading clickable"><span>前端</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="比特币"><a href="#比特币" class="header-anchor">#</a> 比特币</h1> <p>相关链接：<a href="https://www.bilibili.com/video/BV1Vt411X7JF" target="_blank" rel="noopener noreferrer">北京大学肖臻老师《区块链技术与应用》公开课<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="密码学原理"><a href="#密码学原理" class="header-anchor">#</a> 密码学原理</h2> <h3 id="哈希"><a href="#哈希" class="header-anchor">#</a> 哈希</h3> <ul><li><p><strong>crypto-currency 加密货币</strong></p></li> <li><p><strong>cryptographic hash function 哈希散列函数</strong></p></li> <li><p><strong>collision resistance 抗碰撞性</strong></p></li></ul> <p>x ≠ y，H(x)=H(y) 输入空间远远大于输出空间，比如256位的哈希值指的就是输出空间是2^256这么多，输入是无限可能的，输出是固定长度。</p> <p>但是，目前没有找到没有好的方法去找出一个x能得到H（x）等于右边的值。</p> <p>遍历所有输入的可能能去找到这个值，叫做brute-force暴力破解吗，也就是现在矿机所谓的“ <strong>哈希碰撞</strong> ”这个词的来源。</p> <p>哈希防碰撞用处是保证上传和下载的数据是一样的，就是改一点点出来的结果差很多。举个例子，你输入的信息是一部《红楼梦》（当然电脑识别出来就是0和1），然后你在红楼梦的第100页的第五句话把一个逗号改成句号，然后输出的hash值就完全不同了。这就是哈希函数一个非常重要的特性。</p> <p>但是collision resistance目前没有数学证明这个碰撞不会发生，MD5就是最好的例子，之前是很安全的，但是后来找到了破解方法。</p> <ul><li><strong>隐藏性（ Hiding ）或者叫做单向性（one-way ）</strong></li></ul> <p>哈希函数的计算过程是单向不可逆的。x推出H(x)，但是反推没有法子（单向性），也就是说，哈希值没有泄露输入的x的信息。也就是说x的信息被隐藏了起来，这也就就是隐藏性。</p> <p>输入空间要足够大，取值是均匀的，这样就很难暴力破解。</p> <ul><li><strong>digital commitment 数字承诺 digital equiralent of a sealed envelope 数字等效的密封信封</strong></li></ul> <p>简单例子是，有影响力的股评师，今天预测一下明天的股价是不是增长，那么，他如果公开表明币价，可能会影响币价。</p> <p>所以如何表明他确实很准确呢？让他把股评信息写到纸上，或者存到电脑里，但是要求是第二天开盘后，不能偷偷修改内容，这样就不用担心预测影响股价了。那么现在需要做的只是一件事儿：保证他没有篡改自己已经写好的内容。</p> <p>那么，可以用hash算法，预测的结果（信息）是x，对x 哈希函数一下， <strong>公布 hash 值</strong> ，第二天收盘再把x放出来，如果你改了昨天的数据，hash就变了。所有人都可以用hash算一下这个x和昨天公布的hash值进行对比。</p> <p>实际情况下，实际的输入空间不是很大，输入不够随机，担心有人对上升下跌这样的词汇语句进行组合排列，找到这个x，为了保证安全性，会加入一个nonce随机数，公式表达如下。</p> <p>H(x || nonce) nonce是一个随机数</p> <p>意思就是预测的结果信息x后面加个随机数，一起得到hash。</p> <ul><li><strong>puzzlefriendly 谜题友好</strong></li></ul> <p>你要得到一个hash值前面K位是0。你无法知道怎么得到前面是这么多0的x。</p> <p>挖矿就是找nonce，就是这个随机数。</p> <p><strong>H （block header + nonce ）≤target</strong></p> <p>这就是比特币挖矿的基本原理，就是哈希碰撞去找到这个nonce，让他小于一个target（比如32个0等等）。Block header（或者block head）就是区块头包括的信息都是所有矿工都知道的信息（比如version，prehash，merkle root，ntimenbits等等信息），所以大家竞争的是谁先猜出来nonce。</p> <p>备注：在二进制的世界里，因为每一位比特都是0或者1，所以比大小，就是比前面的0的数量，前面32位是0，自然小于前面31位是0（第32位是1），这个target的所谓比大小也就是限定个范围，因为sha256出来的数字都是256位的二进制数字（哈希函数输出值长短固定的特性），比谁前面的0多是很方便的划定结果值的区域的方式。这一点大家忽略的人很多，其实是一个很基础的数学知识，值得注意。</p> <p>挖矿的基本思想就是来自上述的信息。在比特币中的挖矿的过程里实际上就是去找nonce也就是确定了输出范围后，去找输入的值。H(block header + nonce) ≤ target</p> <p>当输入的值（各种信息+nonce）进行hash运算后得到的值符合target的范围，比如说前面35个0就可以了，你猜出来的值输入后得到hash值前面40个都是零，那么肯定符合要求，实际上前面35个0就满足条件了嘛。</p> <p>然后你把这个信息公布出去，别的矿工看到你的nonce值，也去hash一下，很快就知道你这个nonce是合适的，可以满足target的要求。这里就用到了哈希函数的计算速度快的特性</p> <blockquote><p>difficult to solve, but easy to verify.</p></blockquote> <ul><li>SHA-256 (Secure Hash Algorithm)</li></ul> <p>满足 collision resistance、hiding、puzzle friendly</p> <h3 id="签名"><a href="#签名" class="header-anchor">#</a> 签名</h3> <ul><li><strong>公钥、私钥对（public key, private key）</strong></li></ul> <p>来源于非对称加密（asymmetric encryption algorithm），非对称加密的发送者使用接收者的公钥加密，接收者收到后再使用自己的私钥解密。</p> <p>对称加密的发送者和接收者使用相同的密钥（encyption key），有密钥分发的问题。</p> <p>自己发布交易的签名使用自己的私钥，别人验证签名使用公钥。</p> <p>产生公私钥的前提是好的随机源（a  good source of randommness）</p> <h2 id="数据结构"><a href="#数据结构" class="header-anchor">#</a> 数据结构</h2> <h3 id="哈希指针-hash-pointers"><a href="#哈希指针-hash-pointers" class="header-anchor">#</a> 哈希指针 hash pointers</h3> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/25126d34b6777a604a6af5e59edec82f.png" alt="img"></p> <p>A hash pointer is a pointer to where data is stored together with a cryptographic hash of the value of this data at some fixed point in time.</p> <p>哈希指针指向某个特定时刻下，数据及数据的加密后哈希值一起存储的位置。常规指针提供了一种检索数据的方法，而哈希指针还可以验证数据是否未更改。（如果Data改变，那么Hash of Data就会变）</p> <p>Block Chain is a linked list using hash pointers.</p> <h3 id="block-chain"><a href="#block-chain" class="header-anchor">#</a> Block Chain</h3> <p>下图所示为一个Block Chain。</p> <p>在一般性的链表中，每个块（block）都包含自己的数据（data）和一个指向前一个块（block）的指针（pointer）。</p> <p>而在区块链中，前一个块的指针被哈希指针替代。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/a5c8442cd6d0303d84ea6dd19d5a7f80.png" alt="img"></p> <p>哈希链表能防篡改：如果Block1中的data改变，那么Block2中的Hash of Block1就会改变，以此类推，后面的所有块的哈希值就会变，篡改很容易被发现。</p> <p>区块链和普通的链表的区别：</p> <ul><li><p>用哈希指针代替了普通指针（Bblock chain is a linked list using hash pointers）</p> <p>区块链第一个区块叫作创世纪块(genesis block) ， 最后一个区块是最近产生的区块(most recent block)， 每一个区块都包含指向前一个区块的哈希指针。</p></li> <li><p>tamper-evident log</p> <p>一个区块的哈希指针怎么算:是把前面整个区块的内容，包括里面的hash pointer ，合在一起取哈希值。通过这种结构，可以实现tamper-evident log。这个性质是说，不论是在哪个区块做了改动，都会导致系统中保存的哈希值的变化，也就是只要记录那一个哈希值就能检测出区块链任何位置有发生了修改。因为修改了某个区块的内容，会导致它前面的区块（相较它新产生的）区块保存的哈希值对不上了，那个哈希值就也要改，然后再往前的就也要改，就像多米诺骨牌一样。这个也就是和普通链表的区别，普通链表可以修改里面任何一个结点，对整个链表其它结点没有影响，但在区块链里修改一个区块就会影响到所有比它后产生的区块。</p> <p>有了这个性质，某一个用户也就没必要保存系统中的所有区块了，可以只保存最近的一些区块，如果要用到先前产生的区块，再向别人要就可以。</p> <p>比如只保存了下图中绿线右侧的区块，这些是比较新产生的区块，然后如果要用到紫色圈圈出来的区块，可以向别人要。保存的哈希指针在这里可以校验给的区块是不是正确的（取个哈希值然后和保存的哈希指针的哈希值比较一下），只要用自己保存的哈希指针往下个区块校验，然后再拿校验好的区块的哈希指针再往下校验，如此反复就可以了。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/20190706195553244.png" alt="img"></p></li></ul> <h3 id="merkle-tree"><a href="#merkle-tree" class="header-anchor">#</a> Merkle tree</h3> <p>与 binary tree 的区别：<strong>用哈希指针代替了普通指针</strong>。</p> <p>其中最下面一层是数据块(data blocks)，上面三层内部节点都是哈希指针(hash pointers)，第一层是根节点，根节点的区块也可以取个哈希，叫根哈希(root hash))</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/1f153d51855e4dc2824423076e070d00.png" alt="img"></p> <p>和区块链一样，在Merkle Tree中，只要记录下根哈希值，就能检测出对树中任何部位的修改，也就是用根哈希值保护了整棵树上没有篡改。相比前面的区块链这个效率更高。</p> <p>在比特币系统中，Merkle Tree的每个数据块代表着一个交易，整棵树也就是在记录比特币系统中的交易，用根哈希值防止这些交易信息被篡改。</p> <p>这种结构的好处:<strong>只要记住根哈希值，就能检测出对树中任何部位的修改。</strong></p> <blockquote><p>比特币当中各区块之间用哈希指针连接在一起，每个区块所包含的交易组织成一个merkle tree的形式，最下面一行 data blocks 每个区块实际上是一个交易（transaction），每个区块分为两部分，分别是块头和块身(block header, block body)。块头里面有根哈希值，每个区块所包含的所有交易组成的merkle tree的根哈希值存在于区块的块头里面，但是，块头里没有交易的具体内容，只有一个根哈希值，块身里面是有交易的列表的。</p></blockquote> <h3 id="markle-tree的实际用途"><a href="#markle-tree的实际用途" class="header-anchor">#</a> Markle Tree的实际用途</h3> <p>merkle tree 的作用：提供merkle proof</p> <p>比特币中的节点分为两类 : <strong>全节点</strong>（保存整个区块的内容，即块头块身都有，有交易的具体信息）和<strong>轻节点</strong>（只有块头，例如手机上的比特币钱包）</p> <blockquote><p>①全结点
既有块头又有块身的区块，保存了交易的具体信息。</p> <p>②轻结点
只保存了块头，没有保存块身。例如手机上的比特币钱包就使用的是轻结点。</p></blockquote> <ul><li><p>如何向一个轻节点证明某个交易是写入区块链的?</p> <p>例如有人向自己转账比特币，在手机上的比特币钱包使用的是轻结点，轻结点没有块身也就没有存储交易列表，只有一个根哈希值，如何证明这笔交易是真实存在某个区块中的？</p> <p>Merkle proof要做的就是通过区块中的块头中的Merkle Tree的根哈希值证明某个交易是存在于这个区块所对应的Merkle Tree中的，简单的说就是验证一下Merkle Tree中存在某个交易，这也叫作proof of membership或proof of inclusion。这涉及在Merkle Tree中从指定交易的数据结点到根节点的路径。</p> <p>例如，在下图中，天蓝色数据结点是待证明存在的交易，这里轻结点只有一个根哈希值是不够的，要向全结点请求下图中标红的三个哈希值，然后就只需在本地为交易的数据结点向上一步步计算和拼接计算哈希值，最终和根哈希值对比，来知晓这个交易是不是真实存在这个Merkle Tree中的了。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/9b622dcff97947adb1c435ca979a11f2.png" alt="img"></p></li></ul> <p>最上面一行是小型的区块链，该图展现的是一个区块的merkle tree，最下面一行是包含的交易。假设某个轻节点想知道图中黄色的交易，是否包含在了merkle tree里面。该轻节点没有包含交易列表，没有这颗merkle tree的具体内容，只有一个根哈希值。这时轻节点向一个全节点发出请求，请求证明黄色的交易被包含在这颗merkle tree里面的merkle proof。全节点收到这个请求之后，只需要将图中标为红色的这三个哈希值发给轻节点即可。有了这些哈希值之后，轻节点可以在本地计算出图中标为绿色三个哈希值。首先算出黄色交易的哈希值，即它正上方的那个绿的哈希值，然后跟旁边红色的哈希值拼接起来，可以算出上层节点绿色的哈希值。然后再拼接，再算出上层绿色哈希值，再拼接，就可以算出整棵树的根哈希值。轻节点把这个根哈希值和block header里的根哈希值比较一下，就能知道黄色的交易是否在这颗merkle tree里。</p> <blockquote><p>​    全节点在merkle proof 里提供的这几个哈希值（红色的H()），就是从黄色的交易所在的节点的位置到树根的路径上用到的这些哈希值。轻节点收到这样一个merkle proof之后，只要从下往上验证，沿途的哈希值都是正确的即可。(验证时只能验证该路径的哈希值，其他路径是验证不了的，即该图中红色的哈希值是验证不了的)</p> <p>对于一个轻节点来说，验证一个merkle proof 复杂度是多少?
假设最底层有n个交易，则merkle proof 复杂程度是θ(log(n))。</p></blockquote> <p>merkle proof 可以证明 merkle tree 里面包含了某个交易，所以这种证明又叫proof of membership或 proof of inclusion。</p> <blockquote><p>思考：是否存在不安全的情况？如下图我们要验证B，但是H(1)和H(4)都是全节点提供的。全节点可否修改B，通过H(1)调整，使得修改过后的H(1)和轻节点计算出的H(2)一起取得哈希仍然为H(3)？</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L011X1hpYW95ZQ==,size_16,color_FFFFFF,t_70.png" alt="img"></p> <p>实际上，这种情况为人为制造哈希碰撞。由于哈希函数的collision resistance性质，这种情况是不会发生的。从而，保证了系统的不可篡改性。</p> <p>同时，这样一个Markle Proof的事件复杂度为O(log n)，非常高效<strong>证明交易存在</strong>。如果要证明交易不存在，如果不对叶节点规定排序顺序，没有一个效率较高的方法证明不存在。
在比特币系统中，没有相应的需求，所以在比特币系统中并没有对Markle Tree进行排序。</p></blockquote> <ul><li><p>如何证明merkle tree里面没有包含某个交易?</p> <p>即proof of non-membership。可以把整棵树传给轻节点，轻节点收到后验证树的构造都是对的，每一层用到的哈希值都是正确的，说明树里只有这些叶节点，要找的交易不在里面，就证明了proof of non-membership。问题在于，它的复杂度是线性的θ(n)，是比较笨的方法。</p> <p>**如果对叶节点的排列顺序做一些要求，比如按照交易的哈希值排序。**每一个叶节点都是一次交易，对交易的内容取一次哈希，按照哈希值从小到大排列。<strong>要查的交易先算出一个哈希值，看看如果它在里面该是哪个位置。</strong></p> <blockquote><p>比如说在第三个第四个之间，这时提供的proof是第三个第四个叶节点都要往上到根节点。如果其中哈希值都是正确的，最后根节点算出的哈希值也是没有被改过的，说明第三、四个节点在原来的merkle tree里面，确实是相邻的点。要找的交易如果存在的话，应该在这两个节点中间。但是它没有出现，所以就不存在。其复杂度也是log形式，代价是要排序。排好序的叫作sorted merkle tree。</p> <p>比特币中没有用到这种排好序的merkle tree，因为比特币中不需要做不存在证明。</p></blockquote></li></ul> <p>这节讲了比特币中两种最基本的结构:区块链和merkle tree，都是用哈希指针来构造的。</p> <p>除了这两种之外，哈希指针还能用另一个方面。</p> <p>只要一个数据结构是无环的（非循环链表），都能用哈希指针代替普通指针。有环的话存在一个问题，他们的哈希值没法计算，没法确定一个哈希值固定的区块。</p> <h2 id="btc-协议"><a href="#btc-协议" class="header-anchor">#</a> BTC 协议</h2> <h3 id="数字货币和纸质货币的区别"><a href="#数字货币和纸质货币的区别" class="header-anchor">#</a> 数字货币和纸质货币的区别</h3> <p>央行要发行数字货币，如果直接为货币的面额等信息，用央行的私钥签名，然后使用的时候，用户直接拿央行的公钥验证签名，就这样用是行不通的，因为完全可以用这个数字货币再去买东西了，这叫双花攻击（double spending attack）。签名保证了面额等信息不能修改，但这个数字文件可以复制很多份。如果是纸质货币，花出去自己手里就没有了，这是数字货币和纸质货币的区别。</p> <blockquote><p><a href="https://so.csdn.net/so/search?q=%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">去中心化<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>货币要解决两个问题:</p> <p>①数字货币的发行权</p> <p>②怎么验证交易的有效性，防止 double spending attack（双花攻击）。</p></blockquote> <h3 id="两种解决方案"><a href="#两种解决方案" class="header-anchor">#</a> 两种解决方案</h3> <ul><li><p>中心化的方案：</p> <p>仅仅有面额是不够的，每个数字货币还要有编号，先不考虑去中心化，央行还要维护一个数据库，即记录每个编号的数字货币是归哪个用户所有。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/dba256739c1746cd85ff6146a2b80374.png" alt="img"></p> <p>在支付时，不仅要用公钥验证签名是央行签署的，还要通过央行验证该货币是归自己所有，央行再将货币所有者改成支付给的那个用户。不仅数字货币的发行是由央行来做，而且每次交易都要由央行确认其合法性，这种方案是一个<strong>中心化</strong>的方案。</p></li> <li><p>==去中心化的方案==：</p> <p>将央行的职能改成由广大的用户来共同承担，也就是去中心化的方案，这是比特币等数字货币系统要解决的问题，也即：</p> <p>怎么决定数字货币的发行及发行量？</p> <p>怎么验证交易的合法性，防止双花攻击？</p> <p>第一个问题在比特币系统中是挖矿决定的，后面会学到。</p> <p>第二个问题的解决，也是和中心化的方案一样要维护一个数据结构，但不再是由央行来维护，而是由所有用户来共同维护，这个数据结构也不再是关系表，而是区块链。</p> <p>如下图，假设用户A获得了铸币权（发行货币的权利），他发行了10个比特币，即自己获得了10个比特币。然后他将这10个比特币转给B和C，每个人分5个比特币。接下来B给C 2个货币，给D 3个货币。最后C将所得的7个货币全部给E。
<img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/ac7a368445d74836abd1beb7ac2fb8de.png" alt="img"></p> <blockquote><p>比特币系统中每个交易都分为输入部分和输出部分，<strong>输入部分要给出这笔交易的比特币的来源以及付款方的公钥，输出部分要给出收款人的公钥的哈希值</strong>。比特币系统中的收款地址就是收款人的公钥取哈希再经过一些转换得到的。</p></blockquote> <p>这里涉及两种哈希指针，一种就是图中钴蓝色的，将各个区块串起来的哈希指针；另一种是图中深红色的，是为了说明币的来源是从哪个交易来的。</p> <p>这里“说明币的来源”也就防止了双花攻击，如在下图中，B已经将自己的5个比特币花掉了，假设B尝试再花一次，将5个比特币转给F。<strong>这时顺着区块链去检查这个区块到来源交易之间的区块，发现B已经花了来源区块的比特币，说明这新个交易是不合法的，也就不会接受这个区块进入区块链。</strong></p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/61e5a3d0269e444a827f722fbebf612d.png" alt="img"></p> <p>类似于银行没有提供查询某用户的银行账号的功能一样，比特币系统也没有提供查询某用户的公钥或账户地址的功能，要向某用户转账，就需要对方提供公钥或账户地址。这种情况收款方可以把公钥公布在网站上。</p> <p>然而A向B转账，除了A需要知道B的地址，B也需要知道A的公钥。因为一方面A的公钥代表A的身份，B要知道转账的是谁，另一方面是为了验证比特币交易中A的签名（私钥签名公钥验证），也就是说所有结点都需要知道A的公钥才行。</p> <blockquote><p><a href="https://so.csdn.net/so/search?q=%E5%8C%BA%E5%9D%97%E9%93%BE&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">区块链<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>上每个结点都需要独立验证，即使是一个和交易无关的旁观者也要验证这笔交易的合法性。</p></blockquote> <p>在这种情况下，如何知道A的公钥？这里如前面所学A的公钥是A自己写在这笔交易的输入部分里，即在交易中付款方自己宣称的。但这样是否会造成其他人可以伪造成A来发起交易？如B的同伙B’说自己是A，然后用自己的私钥签名，将自己的公钥说是A的公钥放在交易输入部分里，尝试将A账户上的比特币转走。
<img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/b5431a607066421caefa14c33c418e2b.png" alt="img"></p> <p>但因为<strong>币的来源（图中铸币交易）中交易的输出部分有收款人A的公钥的哈希值</strong>，这时B’伪造的公钥的哈希就和A的公钥的哈希对不上了，所以可以防止这种攻击。</p> <p>倘若B’直接使用A的公钥写上去，但因为没有A的私钥，这时签名就无法用A的公钥验证了，显然也是不行的。</p> <blockquote><p>交易的输入部分和输出部分实际上都是脚本，A 的公钥也是写在这笔交易的输入脚本里面。对公钥的验证过程，实际上就是把这笔交易的输入脚本，和币的来源的交易的输出脚本拼在一起，看看能不能顺利执行。</p></blockquote> <p>在前面的几张图里，每个区块里只画了一个交易，实际系统中每个区块中可以有很多交易，这些交易就组成了上节课学习的Merkle Tree。</p></li></ul> <h3 id="区块结构"><a href="#区块结构" class="header-anchor">#</a> 区块结构</h3> <p>块头（Block Header）和块身（Block Body）</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/cd7c5b8918c84458aa0a63187b813557.png" alt="img"></p> <p>上图中连起来的是块头，块身挂在区块上，哈希指针和块身没有直接联系（间接联系就是通过Merkle Tree的根哈希建立的）。</p> <blockquote><p>注意全结点（fully validation node）是有块身的，需要验证所有交易的合法性；轻结点（light node）是没有块身的，没有办法独立验证交易的合法性。
轻结点没有参与区块链的构造和维护，只是利用了区块链中的部分信息。
系统中大部分结点是轻结点，全结点不是很多。</p></blockquote> <ul><li><p>块头（Block Header）</p> <ul><li><p>用的是比特币的哪个版本的协议</p></li> <li><p>指向前一个区块块头的哈希指针（注意！这里的哈希值只计算前一个区块的块头，块头保存的Merkle Tree的根哈希就已经可以保证区块中保存的所有交易没有被篡改了）</p></li> <li><p>整棵Merkle Tree的根哈希值</p></li> <li><p>挖矿的难度目标阈值target</p></li> <li><p>挖矿用的随机数nonce，要使得H ( blockheader) ≤ target</p></li></ul></li> <li><p>块身（block body）</p> <ul><li>交易列表</li></ul></li></ul> <blockquote><p>挖矿求解问题：Hash（block header）&lt;=target
Hash of previous block header只计算区块块头部分的哈希（ Merkle root hash保证了block body内容不被篡改，所以只需要计算block header即可保证整个区块内容不会被篡改）
区块链系统中，轻节点（只存储区块block header信息）只利用区块链，但并不参与区块链系统维护和构造。</p></blockquote> <h3 id="共识协议"><a href="#共识协议" class="header-anchor">#</a> 共识协议</h3> <p>还有一个问题就是，每个账户都可以发布交易，区块链可以看做账本，那么发布的交易应该写在哪个区块里呢？交易广播给每个区块，每个人都在自己本地的区块链上写入交易，如何保证写入后的一致性？也就是说<strong>账本的内容要取得分布式的共识（distributed consensus）</strong>。</p> <p>分布式共识一个简单的例子是分布式哈希表（distributed hash table）</p> <p>分布式系统研究中产生了很多不可能结论（impossibility result）。</p> <ul><li><p>FLP  impossibility result</p> <p>FLP impossibility result讲的是在一个异步的系统（asynchronous system）中，网络传输的时延没有上限，即使只有一个成员是有问题（faulty）的，也不可能取得共识。</p> <p>FLP 是研究分布式系统的三个专家的名字开头字母。</p></li> <li><p>CAP Theorem</p> <p>CAP是分布式系统想要的三个性质，Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性）。而CAP Theorem是说任何一个分布式系统中，CAP三个性质最多只能满足其中两个，不可能三个全满足。</p> <p>分布式共识中一个比较著名的协议是Paxos，这个协议能够保证一致性。即如果该协议达成了共识，这个共识一定是一致的（即不会出现系统中两个成员的共识不一致）。但是Paxos协议是有一个较小的概率（虽然小但是客观存在），使得系统一直无法达成共识。</p> <p>【在这里附上一个Paxos协议详解：https://my.oschina.net/u/150175/blog/2992187】</p></li></ul> <h3 id="比特币中的共识协议"><a href="#比特币中的共识协议" class="header-anchor">#</a> 比特币中的共识协议</h3> <blockquote><p>背景：假设系统中存在部分节点有恶意，但存在比例较小。大多数节点为“好”的节点，在这种情况下进行共识协议设置。
想法1：直接投票
某个节点打包交易到区块，将其发给其他节点，其他节点检查该候选区块，检查若正确投赞成票，若票数过半数，加入区块链。
存在的问题1——恶意节点不断打包不合法区块，导致一直无法达成共识，时间全花费在投票上。
存在的问题2——无强迫投票手段，某些节点不投票（行政不作为）。
存在的问题3——网络延迟事先未知，投票需要等多久？效率上会产生问题。
更大的一个问题——membership。如果是联盟链，对加入成员有要求，可以基于投票。但比特币系统，任何人都可以加入，且创建账户及其简单，只需要本地产生公私钥对即可。只有转账（交易）时候，比特币系统才能知道该账户的存在。这样，黑客可以使用计算机专门生成大量公私钥对，当其产生大量公私钥对超过系统中一半数目，就可以获得支配地位（女巫攻击）。所以，这种简单的投票方案也是不可行的。</p></blockquote> <p>比特币系统中采用了很巧妙的方案解决这个问题。虽然仍然是投票，但并非简单的根据账户数目，而是依据计算力进行投票。
在比特币系统中，每个节点都可以自行组装一个候选区块，而后，尝试各种nonce值，这就是挖矿。[H(block header)&lt;=target]
当某个节点找到符合要求的nonce，便获得了记账权，从而可以将区块发布到系统中。其他节点受到区块后，验证区块合法性，如果系统中绝大多数节点验证通过，则接收该区块为最新的区块并加入到区块链中。</p> <ul><li><p><strong>合法区块被拒绝？</strong></p> <p>如图所示。发生分叉的情况下，暂时保存分叉情况，但区块链只承认最长合法链，随着时间推移，必然存在某一条链变成最长合法链。这样，也就会导致合法区块被拒绝</p></li></ul> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/20200215204910394.png" alt="img"></p> <ul><li><p><strong>分叉攻击</strong></p> <p>如图所示，A用户对上面的A转账给B的记录回滚，从而非法获取利益。在两条链上，发现交易都合法。这是一个典型的双花攻击。A给B转账后，用分叉攻击将钱又转回来，覆盖掉原来的记录。
在比特币系统中，这种情况实际上很难发生。因为大多数矿工认可的是最长的合法链，会沿着上面的链继续挖下去。而A这个攻击者要想回退记录，就必须使得下面的链变得比上面的链还长。理论上来说，攻击者需要达到整个系统中51%的计算力，才能使得这种攻击成功。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/20200215204936788.png" alt="img"></p></li></ul> <h3 id="比特币激励机制"><a href="#比特币激励机制" class="header-anchor">#</a> 比特币激励机制</h3> <p>为什么系统中节点要竞争记账权？需要提供算力和电力成本，节点为什么要去做？</p> <p>比特币系统设计之初便考虑到了这个问题，那就是引入激励机制。比特币通过设置<strong>出块奖励</strong>来解决该问题，一个获得合法区块的节点，可以在区块中加入一个特殊交易（铸币交易）。事实上，这种方式也是唯一一个产生新比特币的途径。</p> <p>比特币系统设计规定，起初每个区块可以获得50个比特币，但之后每隔21万个区块，奖励减半。</p> <p><strong>但是这样就可以了吗？？？</strong>
区块中保存交易记录，那么，会不会存在节点只想发布区块而不想打包交易？中本聪在设计该系统时，引入了交易费。在一个区块中，其输入&gt;=输出，差值便是给区块所属节点的手续费。这些会在后续文章中详细说明。</p> <h3 id="一些问题"><a href="#一些问题" class="header-anchor">#</a> 一些问题</h3> <p>共识协议取得的共识到底是什么？</p> <blockquote><p>在普通的分布式系统中，如分布式哈希表里，取得的共识就是哈希表中的内容。比特币系统中，共识协议取得的共识是去中心化的账本里的交易。</p> <p>只有获得记账权的结点可以往区块里写交易，而获得记账权的途径就是解那个不等式puzzle，根据第一节课学习的哈希函数puzzle friendly的性质，求解这个puzzle的过程没有捷径，只能一个一个nonce去尝试，所以可以作为工作量的证明，算力越强得到出块奖励的概率也就越大，所以才说比特币系统中是靠算力来投票的。</p></blockquote> <p>靠算力投票是如何避免女巫攻击的？</p> <blockquote><p>因为投票是靠算力的，创建多少个账户都没有影响，创建很多账户并不会使每秒尝试的nonce数目增加。</p></blockquote> <p>为什么形容取得记账权的过程为挖矿（mining）？</p> <blockquote><p>矿的数量有限，比特币总量有限。
挖矿的过程很难，挖到矿的回报很大，比特币取得记账权来获得出块奖励也是一样。</p></blockquote> <h2 id="btc-实现"><a href="#btc-实现" class="header-anchor">#</a> BTC 实现</h2> <p>区块链是一个<a href="https://so.csdn.net/so/search?q=%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">去中心化<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的账本，比特币采用了 <strong>基于交易的账本模式</strong> <strong>（transaction-based ledger）</strong>。只记录了转账交易和铸币交易，并没有直接记录每个账户上有多少钱。如果想知道某个比特币账户上有多少钱，要通过交易记录来推算。</p> <h3 id="utxo"><a href="#utxo" class="header-anchor">#</a> UTXO</h3> <p>比特币中的全节点要维护一个叫UTXO（Unspent Transaction Output）的数据结构，即还没有被花出去的交易的输出。一个交易可能有多个输出，被花掉的就不在UTXO里了，如下图所示。<img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/eda228790c0d43e2b9ca43243efcffef.png" alt="img"></p> <p>UTXO集合中的每个元素要给出产生这个输出的交易的哈希值，以及它在这个交易中是第几个输出。用这两个信息就可以定位到一个确定的交易中确定的输出。使用UTXO可以用来快速检测双花攻击，想知道新发布的交易是不是合法的，要查一下全节点存在内存中的UTXO。想要交易的币只有在这个UTXO这个集合里才算是合法的，否则要么是这个币是不存在的，要么是这笔钱已经花过了的。</p> <p>没有花出的币有可能是拥有者不想花或者没办法花（忘记了自己的密钥），但是这些记录都会永远被保存在UTXO中。每个交易可以有多个输入，也可以有多个输出，但是需要满足“所有输入得金额=所有输出得金额”（Outputstotal Inputs = Total Outputs）。有些交易的总输入可能略微大于总输出，如：总输入是1个BTC，总输出是0.99个BTC，这之中的差额就作为记账费给了获得记账权的那个节点。这些差额被称为比特币系统中的交易费（Transaction Fee）。</p> <p>除了基于交易的账本模式之外，还有一种模式，叫基于账户的账本模式（Account-based leger），以太坊系统用的就是这种模式。在这种模式下，系统需要显示地记录每个账户上确切有多少余额。</p> <h3 id="区块链中的例子"><a href="#区块链中的例子" class="header-anchor">#</a> 区块链中的例子</h3> <ul><li><p>基本信息</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/85a18aff62db4371bbaf88b8c769b740.png" alt="img"></p></li> <li><p>Block header</p> <div class="language-c++ extra-class"><pre class="language-text"><code>class CBlockHeader
{
public:
	//header
	int32_t nVersion;//当前使用的比特币协议的版本号，没法修改（4字节）
    uint256 hashPrevBlock;//前一个区块块头哈希值（32字节），不能修改
    uint256 hashMerkleRoot;//Merkle Tree的根哈希值（32字节）；
                  //通过修改Merkle Tree中铸币交易的CoinBase域当作ExtraNonce来调整其根哈希值
    uint32_t nTime;//区块产生时间，有一定调整余地（4字节）；
                    //比特币系统并不要求非常精确的时间，这个时间可以在一定范围内调整
    uint32_t nBits;//挖矿后的目标阈值编码后的版本（4字节）;
                    //只能按照协议中的要求定期进行调整，不能随便改
    uint32_t nNonce;//（4字节）单纯靠调整nonce的值很大概率找不到符合难度要求的
}
</code></pre></div><p>注意，区块中的nonce是4字节即32位整数，也就只$2^{32}$种取值。因为比特币近些年太火爆了，挖矿的人数很多，所以挖矿的难度被调整的很高，<strong>单纯靠调整nonce是很可能得不到符合难度要求的解的（搜索空间不够大）</strong>。<strong>所以区块的块头中哪些域可以改？再来回顾一下块头中的域（括号中是占的字节数)：</strong></p> <ul><li>版本号（4）：不能改</li> <li>前一个区块块头哈希值（32）：不能改</li> <li>Merkle Tree的根哈希值（32）：通过修改Merkle Tree中铸币交易的CoinBase域来调整其根哈希值</li> <li>区块产生的时间（4）：有一定的调整余地，比特币系统并不要求非常精确的时间，这个域可以在一定范围内调整</li> <li>挖矿目标阈值编码后的版本（4）：只能按照协议中的要求定期进行调整，不能随便改</li> <li>nonce（4）：可以改</li></ul></li> <li><p>交易信息</p> <p>铸币交易是没有交易来源的，所以可以在其CoinBase域里随便写入内容，如下图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/6b1069c2905844d39abf6396a23598df.png" alt="img"></p> <p>铸币交易的变化会使该交易的哈希发生变化，变化沿着Merkle Tree一路向上传递，最终使整棵Merkle Tree的根哈希值发生变化，间接地调整块头（Block Header）的哈希值，如图所示。所以可以将这个字段当做一个Extra Nonce，块头的nonce字段不够用，就再拿着这个域的一部分字节一起调整，就增大了搜索空间。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/a9a902dfa1794ac3ba057f9834955f18.png" alt="img"></p></li> <li><p>普通转账交易
比特币系统中的输入和输出都是由脚本指定的。在比特币系统中，验证交易的合法性就是把交易的Input Scripts和Output Scripts配对后执行来完成的，如将本交易中的输入脚本和上一个交易中的输出脚本配对后执行，即可验证其合法性，如图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/ed9fcb0765e4411289e013c20c9bca65.png" alt="img"></p></li> <li><p>概率分析
伯努利试验（Bernoulli trial：a random experiment with binary outcome）。掷硬币就是一个最简单的伯努利试验，要么正面朝上要么反面朝上，这两个概率不一定一样大。对于挖矿而言，也是有成功和失败两种可能，但是成功和失败的概率相差非常悬殊，成功的概率微乎其微。</p> <p>当进行了大量的伯努利试验，这些伯努利试验就构成了伯努利过程（Bernoulli process：a sequence of independent Bernoulli trails）。伯努利过程的一个性质是无记忆性（Memoryless），即做大量的试验，前面的试验结果对后面没有影响。例如，掷硬币很多次都是反面朝上，下一次掷硬币正面朝上的概率也不会增加，也就是说前面的实验结果对于后面实验结果不会产生影响，实验结果相对独立。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/d98e28a809444bbd9ed75f326b77fdb5.png" alt="img"></p> <p>当伯努利过程的n（试验次数）很大而p（每次试验成功概率）很小时，可以近似为泊松分布。这里挖矿就是这样一个试验次数很多每次试验成功概率很小的伯努利过程，所以可以近似为泊松过程（Poisson process）。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/1a4bd1a6444d47ccb1ae461b27312033.png" alt="img"></p></li> <li><p>公平性保证</p> <p>这里的公平性保证又叫Progress Free。出块时间是服从指数分布（Exponential Distribution） 的，整个系统的出块时间会按照比特币协议被调整在10分钟左右。其函数图像大致如图所示，横轴表示出块时间（Time to Next Block），纵轴是概率密度（Probability Density）。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/f462aebd3d1440958a1318c28872346f.png" alt="img"></p> <p>这里的出块时间是整个系统的出块时间并不是每个矿工的出块时间。矿工的出块时间取决于其算力占系统总算力的百分比。Progress Free中，过去做了多少工作不会让后续成功的概率变化。这个性质是必要的，它是挖矿公平性的保证。</p></li> <li><p>比特币区块总量</p> <p>出块奖励是系统中产生新的BTC的唯一途径，而且由协议可知，出块奖励每隔21万个区块要减半，所以新产生的BTC的总量就形成了一个<strong>几何序列</strong>（Geometric Series）。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/d32d2289173249668bab7309d34d7661.png" alt="img"></p> <p><strong>求解比特币挖矿的puzzle除了比拼算力之外，没有任何实际意义，<strong>但</strong>对维护BTC系统的安全性是至关重要的</strong>。Bitcoin is security by mining。挖矿提供了一种凭借算力投票的有效手段。</p></li> <li><p>安全性分析</p> <p>假设在现在的比特币系统中，大部分算力掌握在诚实的节点手里，这只能说明有比较大的概率下一个区块是由诚实矿工发布的，并不能完全保证记账权不会落在有恶意的节点手里。</p> <p>①偷走他人的钱</p> <p>假设一个有恶意的节点M获得了记账权，它想把节点A的钱转走，但由于M没有A的私钥所以没有办法伪造A的签名。如果M任何写个不正确的签名上去，都会导致诚实的节点不会接受这个候选区块，而是继续沿着上一个区块扩展，如图所示。因为这个区块是不合法的，所以多长都不是最长合法链，所以，这种攻击方式属于无效攻击。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/13bbdc9ec25a49b0a620cf83a1791eb1.png" alt="img"></p> <p>②分叉攻击</p> <p>假设M把想要把比特币转给A，然后就紧接着挖矿挖到了一个区块，在这里填写了M把比特币转给自己的交易，以希望沿着这个区块成为最长合法链，这样就能将转给A的区块挤掉，从而实现将花出去的比特币回滚，如下图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/image-20230212200343303.png" alt="image-20230212200343303"></p> <p>假设我们现在将M→A的区块认为是缺省的，把它认为是one confirmation，那么缺省的是要等6个confirmation（大约一小时），才认为one confirmation区块中的交易是不可篡改的。比特币中还存在着zero confirmation，即交易刚发布出去，还没有写入区块链中的时候，就认为交易已经不可篡改了，如图中红线部分就可以认为是zero confirmation。
<img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/image-20230212200624702.png" alt="image-20230212200624702"></p> <p>zero confirmation实际使用的比较广泛，有两个原因：（1）两个交易有冲突，节点接收最先听到的交易。上面分叉攻击的例子中M-&gt;A后的M-&gt;M’，大多诚实节点会将其拒绝。（2）除了区块链之外有其他手段来保护自己的交易。</p></li></ul> <h2 id="btc-网络"><a href="#btc-网络" class="header-anchor">#</a> BTC 网络</h2> <h3 id="btc-网络工作原理"><a href="#btc-网络工作原理" class="header-anchor">#</a> BTC 网络工作原理</h3> <p>比特币工作在应用层（Application Layer），其底层是一个P2P网络。也就是说比特币系统中是在应用层运行比特币协议，其底层也就是网络层运行的是P2P Overlay Network。比特币系统的网络层中的P2P网络是相对简单的，所有节点之间都是相对平等的，没有超级节点（Super Node 或 Master Node）。想要加入这个网络，至少需要一个种子节点（Seed Node），和种子节点联系，它会将它所知道的网络中的其它节点告知你。各个节点之间通过TCP来通信，这样有利于穿透防火墙。当你需要离开网络的时候，也不必通知其它节点，只需要直接退出应用程序，其它结点一直没有听到你的消息，过一段时间就会将你删除掉。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/image-20230212203514173.png" alt="image-20230212203514173"></p> <p>比特币网络的设计原则是简单、鲁棒，而不是高效（Simple,robust,but not efficient）。每个节点维护一个邻居节点的集合，消息在网络中采取以flooding的方式传播，节点第一次听到某个消息，会将它传播给所有邻居节点，同时记录一下自己已经收到过这个消息了，下一次再收到这个消息时就不用再转发给邻居节点了。邻居节点的选取是随机的，没有考虑底层的拓扑结构。比如一个加利福尼亚州的节点可能跟一个阿根廷的节点是邻居节点。这样设计的好处是很大程度上增强了鲁棒性，但是牺牲了效率。在计算机科学中，鲁棒性是指一个计算机系统在执行过程中处理错误或者算法在遭遇输入、运算等异常时继续正常运行的能力。</p> <p>比特币网络的传播属于Best Effort：一个交易发布到BTC网络上，未必所有节点都能收到，有的节点不一定按照比特币协议的要求来转发，可能合法的不转发，不合法的又转发了。而且不同节点收到交易的顺序也很可能是不一样的（网络传输中的延迟可能很大）。这是一个去中心化的系统中要面临的实际问题，只能尽力而为。</p> <h2 id="btc挖矿难度"><a href="#btc挖矿难度" class="header-anchor">#</a> BTC挖矿难度</h2> <h3 id="什么是挖矿难度"><a href="#什么是挖矿难度" class="header-anchor">#</a> 什么是挖矿难度</h3> <p>比特币系统中的挖矿就是通过不断修改区块块头中的nonce和extra nonce的值，使得：$H ( Block Header ) ≤ target$。</p> <p>目标阈值target越小，则mining的难度就越大。所以调整mining难度就是在调整target，以调整目标空间在整个输出空间中所占的比例。比特币中使用的哈希函数是SHA-256，产生的哈希值是256位的，所以整个输出空间是$2^{256}$，调整目标空间所占的比例，直观地看就是最后得到的哈希值的前面有多少个0，这个0越多显然值就越小，也就是挖矿的难度越大。</p> <p>挖矿难度跟目标阈值成反比$difficulty = \frac{difficulty 1 target}{target}$。difficulty1target是指挖矿难度difficulty定义为1时所对应的目标阈值target的值。挖矿难度最小就是1，所以这个常量也就是<strong>target允许的最大值</strong>。</p> <h3 id="为什么要调整挖矿难度"><a href="#为什么要调整挖矿难度" class="header-anchor">#</a> 为什么要调整挖矿难度</h3> <p>随着系统中的总算力的不断增强，如果挖矿难度始终保持不变的话，比特币系统中的平均出块时间就会越来越短，那么平均出块时间总会减小到1s甚至更小。假设比特币系统的出块时间为1s时，也就是说每隔1秒左右时间就有一个新的区块携带着一些列交易被发布到比特币网络上，但是在比特币网络中，区块传播给大多数节点需要几十秒。如果有两个节点几乎同时发布了区块，那么就会出现分叉，如果出块时间很短，就会导致这种分叉成为常态。而且不仅仅是二分叉，可能会出现很多分叉。</p> <p>分叉过多对BTC系统达成共识没有好处，并且会危害比特币系统的安全性，比特币协议假设大部分算力存放在诚实的节点中，系统中算力越强安全性就越好，因为恶意节点进行攻击需要掌握的51%以上的算力的难度就会更大。如果出块时间很短，就会导致分叉过多，这样诚实节点的算力就被分散了，这时恶意节点就可以集中算力扩展恶意的分叉，这样就会导致恶意节点可能不需要掌握51%的算力，就可以达到分叉攻击的目的，这样大大降低了BTC系统的安全性。</p> <p>实际上，比特币系统中的平均出块时间也不一定是最优的，例如以太坊的出块时间是15秒。大幅降低了出块时间，所以以太坊设计了一个新的共识协议——Ghost。在这个协议中，分叉产生的Orphan Block就不能像比特币系统中那样简单丢弃了，而是也要给予一定奖励Uncle Reward。所以，在不同的区块链系统中，不管出块时间设计成多长，都要使其保持稳定，不能允许它无限减少下去。</p> <h3 id="如何调整挖矿难度"><a href="#如何调整挖矿难度" class="header-anchor">#</a> 如何调整挖矿难度</h3> <p>比特币协议中规定，每隔2016个区块（大约每14天）要重新调整一下挖矿难度，即调整目标阈值target，具体的迭代更新公式是$target=target\frac{actuallytime}{expectedtime}$：，这里的expected time为2016*10，actually time是系统中产生最近的2016个区块实际花费的时间。实际的时间越大，就越需要降低难度，即提高target；实际的时间越小，就越需要提高难度，即降低target。为了避免系统中出现某些意外情况，导致系统出现非常大的波动，每次对目标阈值target的调整最大不能超过4倍。相对地target的调整最小也不能小于$\frac{1}{4}$。</p> <h3 id="如果出现恶意节点不调整target"><a href="#如果出现恶意节点不调整target" class="header-anchor">#</a> 如果出现恶意节点不调整target</h3> <p>target是写在BTC系统的代码里的，每产生2016个区块就需要调整target，代码也都是开源的，但是如果存在恶意节点到了该调整的时候不调整target怎么办。这也是一个大部分节点诚实的问题，发布的区块的块头里有个经过“32字节的target压缩编码后”形成的“4字节的nBits域”，如果不按照协议调整target，那么发布的区块的块头里这个4字节的nBits域就是不正确的，诚实的节点不会接收这样的区块。</p> <h2 id="btc-挖矿"><a href="#btc-挖矿" class="header-anchor">#</a> BTC 挖矿</h2> <h3 id="全节点"><a href="#全节点" class="header-anchor">#</a> 全节点</h3> <p>一直在线；</p> <ul><li><p>在本地硬盘上维护完整的区块链信息；</p></li> <li><p>在内存中维护UTXO集合，以便快速检验交易的正确性；</p></li> <li><p>监听比特币网络上的交易信息，验证每个交易的合法性；</p></li> <li><p>决定哪些交易会被打包到区块里；</p></li> <li><p>监听别的矿工挖出的区块，验证其合法性：</p> <p>①区块中的每个交易都要合法，其中包括铸币交易及其出块奖励有没有被篡改；</p> <p>②发布的区块是否符合难度要求（通俗地说，就是检查Block Header取哈希值之后前面是否有足够多的0）；检查Block Header里面难度目标阈值的设置是否正确；全节点需要根据比特币协议的要求，每两周调整的挖矿难度；</p> <p>③检查区块是否在延伸最长合法链。</p></li> <li><p>挖矿：</p> <p>①决定沿着哪条链挖下去？正常一般是沿着最长合法链；</p> <p>②当出现等长分叉的时候选择哪个分叉？缺省情况是选择最先接收到的区块的分叉。</p></li></ul> <h3 id="轻节点"><a href="#轻节点" class="header-anchor">#</a> 轻节点</h3> <ul><li><p>不是一直在线；</p></li> <li><p>不用保存完整区块链，只要保存每个区块块头，需要保存的内容大小大小比全节点小的很多，即区块块头大小比整个区块大小小很多；</p></li> <li><p>不用保存全部交易，只需要保存和自己相关的交易；</p></li> <li><p>没法验证大多数交易的合法性，只能检验与自己相关的交易的合法性；</p></li> <li><p>无法检测比特币网络上发布的区块的正确性，因为无法检查区块中所包含的交易是否合法；</p></li> <li><p>可以验证挖矿的难度，因为挖矿时候计算哈希值只用到块头信息，这部分信息轻节点保留；</p></li> <li><p>只能检测哪个是最长链，不知道哪个是最长合法链，因为无法检测这条链上所包含的交易都是合法的，但是轻节点可以检查这条链上包含的区块都是符合挖矿难度要求的。</p></li></ul> <p>BTC中大部分节点都是轻节点，如果只需要交易不需要挖矿的话，只需要用轻节点即可。</p> <p>挖矿过程中如果发现新发布了一个区块，应当立即停止挖矿，重新组装一系列合法交易组成的候选区块，在刚发布的区块后面继续挖矿。因为挖矿具有无记忆性（memoryless | progress free），所以无论是在刚刚的区块上继续挖，还是新组装一个区块继续挖，挖矿成功的概率是一样的。如果继续挖之前的区块，一方面这个刚发布的区块中的交易可能和刚刚在挖的那个区块有重复，另一个本质的原因就是候选区块的块头有指向前一个区块的哈希指针，而最新的区块已经变了，所以这个哈希指针也要跟着改变。</p> <p>比特币系统中的安全性由密码学保证以及由共识机制保证，即没有私钥就无法转走比特币。这个安全性得以保证的前提是系统中的大多数算力掌握在诚实节点手中。</p> <h3 id="挖矿的趋势"><a href="#挖矿的趋势" class="header-anchor">#</a> 挖矿的趋势</h3> <ul><li><p>设备</p> <p>挖矿的设备越来越趋于专业化，CPU（通用计算）-&gt;GPU（通用并行计算）-&gt;ASIC（专门为挖矿设计的芯片）。ASIC即Application Specific Integrated Circuit，是专门为了挖矿设计的芯片，没有多余的电路，做不了其他事情，其性价比最高，而且为某一种加密货币设计的ASIC芯片只能挖这一种加密货币的矿，除非两个货币用同一个Mining Puzzle。ASIC芯片的研发周期长，风险较大。为了让通用计算机也能参与挖矿过程，抗ASIC芯片化，有些加密货币采用Alternative mining puzzle，以去对抗那些只为了解决特定mining puzzle而设计出来的ASIC矿机。</p></li> <li><p>大型矿池的出现</p> <p>单个矿工即使用ASIC芯片，挖矿从平均收益上看是有利可图的，但是其收益是很不稳定的。我们之前了解过，比特币系统中的平均出块时间是10分钟，但是平均出块时间是相对于比特币系统中的所有矿工而言的。一个矿工用一个矿机挖出矿的时间可能要很久，而且单个矿工还需要承担除了挖矿之外还要承担全节点的其它责任。</p> <p>矿池将很多矿工组织起来，一般的架构就是一个矿主（Pool Manager）全节点去驱动很多矿机，一个矿主下属许多矿工，下属矿工只负责计算哈希值，全节点的其它职能只由矿主来承担，ASIC芯片只能用来计算哈希值，不能进行全节点的操作。有了收益以后再大家一起分配，矿池的出现有便于解决收益不稳定的问题。矿池一般有两种组织形式，一种是像大型计算中心那样，一个大的矿池里面有成千上万的矿机，这些矿机如果属于同一个机构的话，收益的分配就比较方便了。如果矿机来自不同机构，这时候矿工很可能分布在世界各地，只是都加入了这个矿池。矿工加入矿池只需要按照矿池规定的通讯协议和矿主联系，矿主将要计算的哈希值的任务分配给他，矿工计算好后将结果发给矿主，最终得到出块奖励后一起参与分红。</p> <p>如果矿工来自于不同机构，分红的时候显然显然不能按照平均分配的原则，这里就需要用到工作量证明。每个矿工单独挖矿之所以收益不稳定，是因为挖矿难度太大了，所以可以考虑矿池将挖矿的难度降下来。如，本来要求前面有70个0，现在矿池只要求前面有60个0，这样挖到的是一个share（Almost Valid Block），即这个区块差不多在一定程度上是符合难度要求的。矿工挖到这样的share之后提交给矿主，矿主做下记录，记录每个矿工提供过多少个这样的share，用来衡量矿工所做工作量的大小，即根据矿工提交share的个数来分红。</p> <p>矿工能否独吞奖励？每个矿工的任务是由矿主来分配的，矿主负责组装好区块，然后交给矿工去不断尝试nonce和CoinBase transaction中的extra nonce，有可能就是划分一下，然后分配给不同的矿工去做，而铸币交易CoinBase transaction中的收款人地址是矿主的地址，不是任何一个矿工的地址，所以如果矿工自己发布区块是不成立的。如果自己把铸币交易的地址改成自己的，然后去挖矿，这样提交上去的share矿主是不认可的，所以还是没有用。</p> <p>矿工能否捣乱？平时得到share的时候提交给矿主，做工作量证明，当真的挖到符合规定的nonce值的时候不提交，矿工是有可能这么做的。但是这么做对他没有任何经济上的好处，是一种损人不利己的。</p></li> <li><p>矿池的分布数据</p> <p>矿池在各个国家的分布比例如下图所示，</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/8f55c4e8a7bc4f858451023f7df90445.png" alt="img"></p> <p>各个矿池在2022年8月3日的算力分布情况如图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/590119ef1e24486eb8641ad4a1bf0bd4.png" alt="img"></p></li> <li><p>矿池的危害</p> <p>如果没有矿池，如果要发动51%攻击，攻击者要花费大量的硬件成本。有了矿池以后，<strong>矿池实际上将算力集中了起来</strong>，攻击者未必拥有很多算力，只要吸引大量的不明真相的群众将算力集中到自己的矿池就可以。</p> <p>①分叉攻击</p> <p>假设某个矿池掌握了51%的算力，那么该矿池挖到区块的速度是比较快的，甚至可能比现在的最长合法链要快，那么就可能形成分叉攻击，回滚某部分交易。交易对矿工来说是不知道的，他们的算力可能被矿主利用产生分叉攻击，如下图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/efce7b5f81134f589c2fc5d5424584cc.png" alt="img"></p> <p>②Boycott</p> <p>假设攻击者不喜欢某个账户A，他怀疑账户A参与非法交易，想要把账户A封锁掉，他不允许和A有关的所有交易上链。这时，如果有人发布了含有和A有关的交易的区块，他就马上进行分叉，产生一个不包含这些交易的区块，然后不必等候6个确认区块，立即发布到比特币网络上竞争最长合法链，如图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/f86f972006ab44f6b7e1d65cdbcf4a15.png" alt="img"></p></li></ul> <h2 id="btc-脚本"><a href="#btc-脚本" class="header-anchor">#</a> BTC 脚本</h2> <h3 id="交易举例"><a href="#交易举例" class="header-anchor">#</a> 交易举例</h3> <ul><li><p>交易情况总体概述</p> <p>如图所示是一个在<a href="https://www.blockchain.com/explorer?view=btc" target="_blank" rel="noopener noreferrer">Blockchain.info<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>上面查找到的交易信息。可以看到这个交易有一个输入和两个输出，两个输出都还没有被花出去。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/0a40d54b8b2d43f6a98d1dd6a1df4d6e.png" alt="img"></p> <p>其输入的具体信息，输出的具体信息如图1-3所示。</p></li> <li><p>输入脚本</p> <p>输入脚本包含两个操作，分别将两个很长的数压入栈中，如图所示。比特币使用的<a href="https://so.csdn.net/so/search?q=%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">脚本语言<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是非常简单的，唯一能访问的就是一个<strong>堆栈</strong>，不像通用的编程语言（如C或C++等），有全局变量、局部变量和动态分配等问题。这里的脚本语言就是一个栈，所以是基于栈的编程语言。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/57110b86df4c4b9c84c2f590e783f5ed.png" alt="img"></p></li> <li><p>输出脚本</p> <p>输出脚本有两行，分别对应上面的两个输出，<strong>每个输出有自己单独的一段脚本</strong>，如图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/ae3b5a0d57d4402ab6fdbc91e42d6158.png" alt="img"></p></li></ul> <p>这个交易还没有得到确认，所以还具有一定程度的回滚的可能性Confirmations代表该交易被确认的个数，如图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/54022fddbcd44d2d98d4f5e18d5ad1dd.png" alt="img"></p> <ul><li><p>交易结构</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token property">&quot;result&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token property">&quot;txid&quot;</span><span class="token operator">:</span><span class="token string">&quot;921a.dd24&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 交易的id</span>
    <span class="token property">&quot;hash&quot;</span><span class="token operator">:</span><span class="token string">&quot;921a.dd24&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 交易的哈希值</span>
    <span class="token property">&quot;version&quot;</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 使用的比特币协议版本号</span>
    <span class="token property">&quot;size&quot;</span><span class="token operator">:</span><span class="token number">226</span><span class="token punctuation">,</span> <span class="token comment">// 交易的大小</span>
    <span class="token property">&quot;locktime&quot;</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// 设定交易的生效时间，0代表立即生效，如果非0代表经过几个区块后才允许上链</span>
    <span class="token property">&quot;vin&quot;</span><span class="token operator">:</span><span class="token punctuation">[</span>...<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 交易的输入</span>
    <span class="token property">&quot;vout&quot;</span><span class="token operator">:</span><span class="token punctuation">[</span>...<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 交易的输出</span>
    <span class="token property">&quot;blockhash&quot;</span><span class="token operator">:</span><span class="token string">&quot;0000000000000000002c510d..5c0b&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 交易所在区块的哈希值</span>
    <span class="token property">&quot;confirmations&quot;</span><span class="token operator">:</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token comment">// 目前已经有几个确认，包括自己及其后面有多少区块上链</span>
    <span class="token property">&quot;time&quot;</span><span class="token operator">:</span><span class="token number">1530846727</span><span class="token punctuation">,</span> <span class="token comment">// 交易产生的时间戳，即从交易产生到现在过来多少秒</span>
    <span class="token property">&quot;blocktime&quot;</span><span class="token operator">:</span><span class="token number">1530846727</span> <span class="token comment">// 该交易所在的区块的产生时间，即从交易所在的区块产生到现在过来多少秒</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>交易的输入结构</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token property">&quot;vin&quot;</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span> <span class="token comment">// 交易的输入结构，是一个数组</span>
	<span class="token property">&quot;txid&quot;</span><span class="token operator">:</span><span class="token string">&quot;c0cb...c57b&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 该输入的币的“来源交易”的哈希值</span>
	<span class="token property">&quot;vout&quot;</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// 该输入对应的“来源交易”的第几个输出，这实际上是一个索引值</span>
	<span class="token property">&quot;scriptsig&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span> <span class="token comment">// 输入脚本，这里是最简单的形式，只有签名，后面会用“input script”指代</span>
                 <span class="token comment">// 如果有多个输入，每个输入都需要指明币的来源，并给出签名   </span>
		<span class="token property">&quot;asm&quot;</span><span class="token operator">:</span><span class="token string">&quot;3045...0018&quot;</span><span class="token punctuation">,</span>
		<span class="token property">&quot;hex&quot;</span><span class="token operator">:</span><span class="token string">&quot;4830...0018&quot;</span>
	<span class="token punctuation">}</span>	
<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
</code></pre></div></li> <li><p>交易的输出结构</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token property">&quot;vout&quot;</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span>
	<span class="token property">&quot;va1ue&quot;</span><span class="token operator">:</span><span class="token number">0.22684000</span><span class="token punctuation">,</span> <span class="token comment">// 输出金额，即给对方转过去多少比特币</span>
	<span class="token property">&quot;n&quot;</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// 序号，表示这是这个交易中的第几个输出，实际上也是一个索引</span>
	<span class="token property">&quot;scriptPubKey&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span> <span class="token comment">// 输出脚本，之后将以“output script”指代</span>
		<span class="token property">&quot;asm&quot;</span><span class="token operator">:</span><span class="token string">&quot;DUP HASH160 628e...d/43 EQUALVERTFY CHECKSTG&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 输出脚本的内容，包含一系列操作</span>
		<span class="token property">&quot;hex&quot;</span><span class="token operator">:</span><span class="token string">&quot;76a9.88ac&quot;</span><span class="token punctuation">,</span>
		<span class="token property">&quot;regsigs&quot;</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 这个输出需要多少个签名才能兑现，有的输出需要多重签名，这里只需要一层签名</span>
		<span class="token property">&quot;type&quot;</span><span class="token operator">:</span><span class="token string">&quot;pubkeyhash&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 输出的类型，此处pubkeyhash是公钥的哈希</span>
		<span class="token property">&quot;addresses&quot;</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&quot;19z8LJkNXLrTv2QK5jgTncJCGUEEfpQvSr&quot;</span><span class="token punctuation">]</span> <span class="token comment">// 输出的地址</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
	<span class="token property">&quot;va1ue&quot;</span><span class="token operator">:</span><span class="token number">0.53756644</span><span class="token punctuation">,</span>
	<span class="token property">&quot;n&quot;</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
	<span class="token property">&quot;scriptPubKey&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>
		<span class="token property">&quot;asm&quot;</span><span class="token operator">:</span><span class="token string">&quot;DUP HASH160 da7d...2cd2 EQUALVERIFY CHECKSIG&quot;</span><span class="token punctuation">,</span>
		<span class="token property">&quot;hex&quot;</span><span class="token operator">:</span><span class="token string">&quot;76a9.88ac&quot;</span><span class="token punctuation">,</span>
		<span class="token property">&quot;regsigs&quot;</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
		<span class="token property">&quot;type&quot;</span><span class="token operator">:</span><span class="token string">&quot;pubkeyhash&quot;</span><span class="token punctuation">,</span>
		<span class="token property">&quot;addresses&quot;</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&quot;1LVGTpdyeVLCLCDK2m9f7Pbh7zwhs7NYhX&quot;</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">]</span>
</code></pre></div></li></ul> <h3 id="脚本举例"><a href="#脚本举例" class="header-anchor">#</a> 脚本举例</h3> <p>这是一个小型<a href="https://so.csdn.net/so/search?q=%E5%8C%BA%E5%9D%97%E9%93%BE&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">区块链<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，如图所示，前面有一个A→B的一个转账交易，后面隔两个区块之后又有一个B→C的转账交易。B→C的这个交易中比特币的来源是A→B这个交易，所以我们可以看见如下图所示的B→C的交易中的txid和vout是指向A→B这个交易。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/5aff249dc8454740a3985f9010fe700f.png" alt="img"></p> <p>在早期的比特币系统中，B→C这个交易的输入脚本和A→B这个交易的输出脚本拼在一起执行的。后来出于安全因素的考虑，这两个脚本改为分别执行，首先执行输入脚本，如果没有出错，那么再执行输出脚本，如果能顺利执行，并且最后得到非零值（true），那么则说明这个交易就是合法的。如果一个交易有多个输入，其中每个输入脚本都要找到前面特定区块中所对应的输出脚本，匹配之后来进行验证。全部验证通过后，这个交易才是合法的。</p> <h3 id="输入输出脚本的形式"><a href="#输入输出脚本的形式" class="header-anchor">#</a> 输入输出脚本的形式</h3> <p>① P2PK（Pay to Public Key）</p> <ul><li><p>脚本内容</p> <p>这是最简单的一种形式，输出脚本中直接给出收款人的公钥。第二行的 CHECKSIG 是检查签名的操作，在输入脚本里直接给出签名就可以，这个签名是用私钥对这个输入脚本所在交易的签名，这种形式是最简单的，因为Pubic Key是直接在输出脚本中给出的。</p> <div class="language- extra-class"><pre class="language-text"><code>input script：
	PUSHDATA(Sig) // 签名，用私钥对输入脚本所在的整个交易的签名
output script：
	PUSHDATA(PubKey) // 收款人的公钥
	CHECKSIG // 检查签名的操作
</code></pre></div></li> <li><p>脚本执行</p> <p>把输入脚本和输出脚本连接起来的结果，实际代码中出于安全考虑，这两段代码是分别执行的。这里为了方便就把这两个脚本的代码拼接显示，逐条执行。</p> <div class="language- extra-class"><pre class="language-text"><code>PUSHDATA(Sig) // 把输入脚本中提供的签名压入栈

PUSHDATA(PubKey) // 把输出脚本中提供的公钥压入栈
CHECKSIG // 把栈顶的两个元素弹出，用公钥检查这个签名是否正确
 // 如果正确，则返回True，说明验证通过；否则，执行出错，说明该交易非法。
</code></pre></div></li> <li><p>实例</p> <p>上面交易的输入脚本就是将签名压入栈，下面这个交易，是上面交易的币的来源，其输出有两行，第一行是将公钥压入栈，第二行是进行CHECKSIG，如下图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/8946e0226805469f925ad0e98155a018.png" alt="img"></p></li></ul> <p>② P2PKH（Pay to Public Key Hash）</p> <ul><li><p>脚本内容</p> <p>P2PKH的输出脚本中没有给出收款人的公钥，给出的是公钥的哈希值。公钥是在输入脚本中给出的，输入脚本既要给出签名，还要给出公钥，输出脚本中其他还有一些为了验证签名正确性的操作。P2PKH是最常用的一种形式。</p> <div class="language- extra-class"><pre class="language-text"><code>input script:
	PUSHDATA(Sig)
	PUSHDATA(PubKey)
output script:
	DUP
	HASH160
	PUSHDATA(PubKeyHash)
	EQUALVERIEY
	CHECKSIG
</code></pre></div></li> <li><p>脚本执行</p> <div class="language- extra-class"><pre class="language-text"><code>PUSHDATA(Sig)//将签名压入栈
PUSHDATA(PubKey)//将公钥压入栈

DUP//把栈顶元素，即公钥PubKey，复制一遍
HASH160//弹出栈顶元素，取哈希，将得到的哈希值再压入栈
PUSHDATA(PubKeyHash)//将输出脚本中提供的公钥哈希值压入栈
EQUALVERIEY//弹出栈顶两个元素，做对比，防止有人冒名顶替，若它们从栈顶消失，则两个哈希值相等
CHECKSIG//弹出栈顶两个元素，用公钥检查这个签名是否正确
//如果正确，则返回True，说明验证通过，整个脚本彻底运行结束；否则，执行出错，说明该交易非法。
</code></pre></div></li> <li><p>实例</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/79a9b582e5db4c4c9f41b0b1dc6b18be.png" alt="img"></p></li></ul> <p>③ P2SH（Pay to Script Hash）</p> <ul><li><p>脚本内容</p> <p>这是最复杂的一种形式，这种形式下<strong>输出脚本给出的不是收款人的公钥的哈希，而是收款人提供的赎回脚本（Redeem Script）的哈希</strong>。将来要花这个输出脚本的BTC的时候，相应交易的输入脚本要给出赎回脚本的具体内容，同时还要给出让赎回脚本能正确运行所需要的签名。</p> <div class="language- extra-class"><pre class="language-text"><code>input script:
	...
	PUSHDATA (Sig)//签名
	...
	PUSHDATA(serialized redeemScript)//序列化赎回脚本
output script:
	HASH160
	PUSHDATA(redeemScriptHash)//赎回脚本的哈希
	EQUAL
</code></pre></div><p>input script要给出一些数目不定的签名及一段序列化的Redeem Script（赎回脚本）。验证分如下两步：</p> <ul><li><p>验证输入脚本里给出的RedeemScript是否与输出脚本中的给出的Redeem Script的哈希值匹配。如果不匹配，则说明输入脚本给出的Redeem Script是不对的。</p></li> <li><p>将赎回脚本的内容当作操作指令执行，看能否顺利执行，若两步验证都通过了，才能说明交易合法。</p></li></ul> <p>redeemScript 的形式</p> <ul><li><p>P2PK 形式</p></li> <li><p>P2PKH 形式</p></li> <li><p>多重签名形式</p></li></ul></li> <li><p>用P2SH实现P2PK的功能</p> <div class="language- extra-class"><pre class="language-text"><code>redeemScript:  // 赎回脚本
	PUSHDATA(PubKey) // 公钥
	CHECKSIG // 检查签名
input script: // 输入脚本
	PUSHDATA(Sig) // 签名
	PUSHDATA(serialized redeemScript) // 序列化的赎回脚本
output script: // 输出脚本，验证输入脚本中给出的赎回脚本是否正确
	HASH160
	PUSHDATA (redeemscriptHash)
	EQUAL
</code></pre></div><p>执行过程：</p> <ul><li><p>第一阶段的验证</p> <p>像之前一样把输入脚本和输出脚本拼接到一起，前两行来自输入脚本，后面三行来自于输出脚本。</p> <div class="language- extra-class"><pre class="language-text"><code>PUSHDATA(Sig) //  将输入脚本的Signature压入栈
PUSHDATA(serialized redeemScript) // 将序列化的赎回脚本压入栈
HASH160 // 取哈希值，得到赎回脚本的哈希值
PUSHDATA (redeemscriptHash) // 将输出脚本中赎回脚本的哈希值压入栈
EQUAL // 比较栈顶两个哈希值是否相等，如果相等，则这两个哈希值从栈顶消失
</code></pre></div></li> <li><p>第二阶段的验证</p> <p>将第一阶段输入脚本中提供的序列化的赎回脚本进行反序列化，这个反序列操作，在代码部分没有展现出来，这个是每个节点需要自己完成的，然后再执行赎回脚本。</p> <div class="language- extra-class"><pre class="language-text"><code>PUSHDATA(PubKey) // 将公钥压入栈
CHECKSIG // 验证输入脚本中给出的Signature的正确性，验证之后整个P2SH才算执行完
</code></pre></div></li></ul></li></ul> <h3 id="多重签名"><a href="#多重签名" class="header-anchor">#</a> 多重签名</h3> <p>P2SH的常见应用场景就是对多重签名的支持。比特币系统中一个交易输出可能要求使用它的交易输入提供多个签名，才能把比特币取出来。比如某个公司可能要求5个合伙人中的任意三个提供签名，才能把公司的钱转走。这样设计不但为私钥的泄露提供了一定安全性保护，也为私钥的丢失提供了一定的容错性。这个操作是通过“CHECKMULTISIG”来实现的。</p> <p>① 最早的多重签名（目前已经不推荐使用）</p> <ul><li><p>脚本内容</p> <div class="language- extra-class"><pre class="language-text"><code>inputScript: // 提供N个公钥中任意M个合法的签名
	X // 在输入脚本里往栈中添加一个没用的元素，抵消掉比特币其中的一个bug。
	PUSHDATA(Sig_1) // 给出的签名的顺序需要与公钥顺序一致
	PUSHDATA(Sig_2)
    ...
	PUSHDATA(Sig_M)
outputScript:
	M // 阈值
	PUSHDATA(pubkey_1)
	PUSHDATA(pubkey_2)
	...
	PUSHDATA(pubkey_N)
	N // 公钥的个数
	CHECKMULTISIG
</code></pre></div></li> <li><p>脚本执行</p> <div class="language- extra-class"><pre class="language-text"><code>FALSE // 压入栈的多余元素
PUSHDATA(Sig_1) // 将两个签名压入栈
PUSHDATA(Sig_2)
2 // 阈值M压入栈
PUSHDATA(pubkey_1) // 将三个公钥分别压入栈
PUSHDATA(pubkey_2)
PUSHDATA(pubkey_3)
3 // 将公钥数目N压入栈
CHECKMULTISIG // 对比看堆栈中是否包含N个签名中的M个，这里是3个签名中的2个
// 如果是，则验证通过
</code></pre></div><p>这是最早的多重签名，并没有用到P2SH，就是用比特币脚本中原生的CEHCKMULTISIG实现的。  这样在实际使用时有些不方便的地方，例如某个电商平台开通了比特币支付渠道，按要求需要有5个合伙人中3个人的签名才能把比特币转走。但这样做之后，用户在使用比特币支付的时候，生成的转账交易里也需要给出5个合伙人的公钥，同时还要给出N和M的值。而这些公钥，以及N和M的值就要电商平台公布给用户，而且不同的电商平台规则也不一样，这就让用户生成转账交易变得不方便。这就给用户生成转账交易带来了不便，因为这些复杂性都暴露给用户了。</p></li></ul> <p>② 用P2SH实现多重签名</p> <ul><li><p>脚本内容</p> <p>与之前的的多重签名相比，P2SH的本质是<strong>将复杂性从输出脚本转移到了赎回脚本中</strong>，输出脚本变得十分简单，只需要给出赎回脚本的哈希值就行了。N个公钥以及N、M的值都在赎回脚本中给出，而赎回脚本由输入脚本提供（也就是说由收款人提供），这样也就大大降低了用户的工作量。</p> <div class="language- extra-class"><pre class="language-text"><code>inputScript://提供N个公钥中任意M个合法的签名
	X//在输入脚本里往栈中添加一个没用的元素，抵消掉比特币其中的一个bug。
	PUSHDATA(Sig_1)//给出的签名的顺序需要与公钥顺序一致
	PUSHDATA(Sig_2)
    ...
	PUSHDATA(Sig_M)
    PUSHDATA(serialized RedeemScript)
outputScript:
    HASH160
    PUSHDATA(RedeemScriptHASH)
    EQUAL
redeemScript：
	M//阈值
	PUSHDATA(pubkey_1)
	PUSHDATA(pubkey_2)
	...
	PUSHDATA(pubkey_N)
	N//公钥的个数
	CHECKMULTISIG
</code></pre></div><p>从用户的角度来看，采用这种P2SH的支付方式，和P2PKH支付方式没有多大区别，只不过输出脚本中的是赎回脚本的哈希值而不是公钥的哈希值，当然，输出脚本的写法上也有一些细微的区别。输入脚本就是电商要把这笔比特币转出去时候用的，这种方式下输入脚本要包含让赎回脚本验证通过的M个签名，以及赎回脚本的序列化版本。如果电商平台将来改变了采用的多重签名规则，就只需要改变一下赎回脚本的内容和输入脚本中的内容，然后把新的赎回脚本的哈希值公布出去就可以了。对用户而言也只是付款时候输出脚本中要包含的哈希值发生了变化，其他的变化是用户不需要知道的内容。</p></li> <li><p>脚本执行</p> <ul><li><p>第一阶段验证</p> <div class="language- extra-class"><pre class="language-text"><code>FALSE // 多余的元素压入栈
PUSHDATA(Sig_1) // 将签名Sig_1压入栈
PUSHDATA(Sig_2) // 将签名Sig_2压入栈
PUSHDATA(serialized RedeemScript) // 将序列化的赎回脚本压入栈
HASH160 // 对序列化的赎回脚本取哈希，然后将哈希值压入栈
PUSHDATA(RedeemScriptHASH) // 将输出脚本中提供的赎回脚本的哈希值压入栈
EQUAL // 将栈顶的两个哈希值进行对比，若相等，则第一阶段验证完成
</code></pre></div></li> <li><p>第二阶段验证</p> <div class="language- extra-class"><pre class="language-text"><code>2 // 阈值，压入栈
PUSHDATA(pubkey_1) // 将pubkey_1公钥压入栈
PUSHDATA(pubkey_2) // 将pubkey_2公钥压入栈
PUSHDATA(pubkey_3) // 将pubkey_3公钥压入栈
3 // 公钥的个数，压入栈
CHECKMULTISIG // 检查多重签名的正确性
</code></pre></div></li></ul></li></ul> <h3 id="proof-of-burn"><a href="#proof-of-burn" class="header-anchor">#</a> Proof of Burn</h3> <p>这是一种特殊的输出脚本，执行到RETURN语句就会出错，然后验证就会终止，后面的语句完全没有机会执行，包含这个操作的语句永远不可能通过验证。这个脚本常常用来销毁比特币。</p> <p>为什么要销毁比特币？ ①一些小的加密货币（AltCoin: Alternative Coin），除了比特币之外的加密货币都可以被认为是小币种，他们要求销毁一定数量的比特币可以得到一定数量的这种币。这时Proof of Burn就可以证明自己销毁了这些比特币。②往区块链里写入一些内容。因为区块链是不可篡改的账本，有人就利用这个特性向其中写入一些需要永久保存的内容。比如，第一节课学的Digital Commitment，即需要证明自己在某一时间知道某些内容。例如某些知识产权保护，可以将知识产权取哈希之后，将哈希值放在这种输出脚本的RETURN语句的后面。反正哈希值很小，而且哈希值没有泄露原来的内容，将来出现纠纷时，再将原来的内容公布出去，大家在区块链上找到这个交易的输出脚本里的哈希值，就可以证明自己在某个时间点已经掌握了这些知识了。</p> <p>对于上面说的②的应用场景，回想在前面学习到铸币交易时，铸币交易的CoinBase域也可以随便写什么内容，为什么不在那里写呢，还不需要销毁比特币？这种方法很难，必须要获得记账权，而且是在CoinBase域设定好内容的情况下，去获得记账权。根本来说，是因为发布交易不需要有记账权，但发布区块需要取得记账权。任何用户都可以用Proof of Burn的方法，销毁极少量的比特币，换取向比特币系统的区块链中写入一些内容的机会。</p> <ul><li><p>销毁了比特币的形式：</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/87b699064c8345fa857ccf0213f841bf.png" alt="img"></p></li> <li><p>没有销毁比特币，仅仅支付了交易费，也可以向区块链中写入内容：</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/95c2edd67d9b4acab69e9e8277ddabff.png" alt="img"></p></li></ul> <p>比特币系统中使用的脚本语言很简单，甚至不支持循环，这样设计也有其用意，不支持循环也就不会有死循环。后面学的以太坊的脚本语言就是图灵完备的，这样就靠其它机制来防止进入死循环等。比特币的脚本语言针对比特币应用场景做了很好的优化，在密码学方面的功能尤其强大，如检查多重签名时的CHECKMULTISIG操作一条就能实现，这是其强大之处。</p> <h2 id="btc-分叉"><a href="#btc-分叉" class="header-anchor">#</a> BTC 分叉</h2> <h3 id="分叉种类"><a href="#分叉种类" class="header-anchor">#</a> 分叉种类</h3> <ul><li><p>State Fork</p> <p>区块链原来是一条链，现在变成了两条，这样的情况就叫做分叉。分叉可能是多种原因造成的，如挖矿的时候有两个结点差不多同时挖到矿，这时两个结点都可以发布区块，就可能出现临时性的分叉，我们把这样的分叉叫State Fork：由于对区块链当前的状态有意见分歧而产生的分叉。分叉攻击（Forking Attack）也属于这样的State Fork，只不过这种意见分歧是人为造成的，这种情况也称为Deliberate Fork。</p></li> <li><p>Protocol Fork</p> <p>在比特币系统中，如果要修改比特币协议需要软件升级，在去中心化的系统中，没办法要求所有的节点都升级软件。假设大部分节点升级了软件，少部分节点因为某些原因（如没来得及升级或不同意协议的修改）没有升级，这种情况也会产生分叉，我们将这种分叉称为Protocol Fork，即对比特币协议产生了分歧，使用不同版本的协议而产生的分叉。根据对协议修改的内容不同，可以进一步分成硬分叉（Hard Fork）和软分叉（Soft Fork）。</p></li></ul> <h3 id="硬分叉和软分叉"><a href="#硬分叉和软分叉" class="header-anchor">#</a> 硬分叉和软分叉</h3> <ul><li><p>硬分叉</p> <p>如果对比特币协议增添一些新特性、扩展一些新的功能，这时还没有升级软件的这些节点不认可这些新特性，认为这些新的特性是非法的，这个时候就属于我们对比特币协议的内容产生了意见分歧，也就会导致分叉。硬分叉的一个典型的例子就是比特币中的区块大小限制（Block Size Limit），比特币协议中规定区块大小限制是1M字节（平均每十分钟产生一个1M大小的区块，约能容纳4000个交易左右，即每秒钟大约7笔交易），就是说每个区块不能超过1M大小，有些人认为这个限制太小，影响了比特币的吞吐量（Thoughput），限制了交易上链的速度，增加了延迟。</p> <p>假设软件更新了，将区块大小限制从1M提高到4M，假设大多节点更新了软件将区块大小限制调整至4M，少数节点不更新（这里所说的大多数节点和少数节点都是依照节点的算力来计算的，而不是传统意义上的节点个数）。也就是说，假设系统中拥有大多算力的节点都更新了软件，承认这项协议。</p> <p>当系统运行起来，假设有一个区块链，如图所示；</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/f5424d5ff45a489b91252b2b4e2ec3c4.png" alt="img"></p> <p>新节点沿着它挖出一个新的区块，这个区块是比较大的假设其大小为4M，如图所示；</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/1c377373f1cf42fab570efa424a24ef4.png" alt="img"></p> <p>新节点挖出第二个区块，假设其大小为4M，如图所示；</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/3ab6bb01d59a4373a394d9a4800dd7ed.png" alt="img"></p> <p>新节点挖出第三个区块，假设其大小为1M，如图1-4所示；</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/3fbf62f8b1f440498e46f8fd5b255169-1677241588689-12.png" alt="img"></p> <p>无论新节点挖矿的链有多长，旧节点认为他包含非法内容，所以他沿着之前的链往下挖，下方是旧节点挖到的区块，假设其大小为1M，如图所示；</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/2ac8dfdbf417404cbec981ef80c3cf04.png" alt="img"></p> <p>新节点虽然不会认为旧节点挖出的区块属于非法区块，但是由于它不在最长合法链上，所以新节点也不会沿着它继续往下挖，如图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/1fa4497d61ed412f8bf9c7a6750e441e.png" alt="img"></p> <p>新节点：认可旧节点挖出的区块，但是由于新旧节点的算力悬殊较大，新节点挖矿的链始终是最长合法链。</p> <p>旧节点认为：新节点挖矿的链上包含非法区块，所以无论多长都没有意义。这种分叉是永久性的，只要这部分旧节点不更新软件，这个分叉就不会消失。</p> <p>比特币网络中，会有部分很保守的人，像这样提高区块大小限制的协议，势必会有一些节点不同意，而且区块的大小也并不是越大越好（比特币系统底层工作原理是P2P Overlay Network，它传播主要采用的是flooding的方式，对带宽的消耗是很大的，带宽是瓶颈），所以会产生硬分叉。</p> <p>那么出现硬分叉之后挖到的区块还是否有用，出块奖励还有吗？其实，在出现硬分叉之后，出现了两条平行运行的链，两条链上的比特币互不相干的，各挖各的矿。在某条链上的出块奖励，对于认可这条链为最长合法链的节点来说是有效的，对认可另一条链的则是无效的，而分裂之前产生的BTC则是在两条链上都认可的。（这就像是ETH和ETC的关系）从这个意义上讲，硬分叉可以认为是产生了新的一种加密货币。为避免双花操作或交易回滚操作，一般会在硬分叉后设置Chain ID，来标识这两条链为两条独立的链。</p></li> <li><p>软分叉</p> <p>如果对比特币协议加了一些限制，使得原本某些合法的交易或区块，在限制后的新协议中变成不合法，那么形成的分叉是软分叉。</p> <p>假设对软件进行更新：使区块大小限制从1M变为0.5M。这里仍然假设被分为了旧节点和新节点，大多算力的是新节点，也就是已经更新了协议的节点，区块限制为0.5M；少部分为旧节点，仍然认定区块限制为1M。这时，新节点挖出的区块，旧节点会认为是合法的；但旧节点挖出的区块，新节点很可能认为它是不合法的（因为很可能它会超过新节点的区块限度，即区块大小在0.5M内）。</p> <p>假设还是那条区块链，如图所示；</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/61dd9b699ea64a419aa125f5c7e5bfd2.png" alt="img"></p> <p>新节点挖出区块，假设其大小为0.5M，如图所示；</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/2292c82ede114a8bb9c32462078023c1.png" alt="img"></p> <p>旧节点认为新节点挖出的区块是合法区块，所以他沿着这个区块继续挖，挖出一个区块，假设其大小为1M，如图所示；</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/01bf1646d9124f398af4ecab8df96516.png" alt="img"></p> <p>旧节点产生的新区块超过新节点区块限制，新节点认为它不合法，所以会沿着上一个合法区块继续挖，假设现在新节点挖到区块，大小为0.5M，如图所示；</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/edc783cadf1f4ae8a0b710d66f9d6435.png" alt="img"></p> <p>新节点对于现在分叉只认为下面的分叉是合法的所以它继续发布新的区块在下面的链上，假设其大小为0.5M，如图所示；</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/d4323b5f34e14224a2136d81b00b5b40.png" alt="img"></p> <p>旧节点认可所有节点，但是由于下方的链是最长合法链，所以它会继续往后扩展，如图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/8e836b0ced4e40898bbcc6467be1a941.png" alt="img"></p> <p>在这种情况下，会持续出现软分叉，只要旧节点不更新协议，挖出的区块就一直无法上链，相当于一直白挖。相比硬分叉，<strong>软分叉即是非永久存在的分叉，只会临时存在一段时间</strong>。</p></li> <li><p>实际情形中可能出现软分叉的情况</p> <p>①给某些目前协议中没有规定的域增加新的含义，赋予他们一些新的规则。</p> <p>典型的就是在铸币交易中有个CoinBase域，它的作用没有明确规定，也没有人检查，我们之前讲过，可以把它的前八个字节作为Extra Nonce和Nonce一起调整，增大挖矿的搜索空间。但是，它后面的空间用来做什么并没有明确规定。有人提出可以把它作为UTXO（当前还没花掉的交易的输出）的根哈希值的存放处。目前UTXO用作记录当前还没花掉的交易的输出，目前只是每个全节点自己在维护，目的就是实现快速查找，防止双花操作，判断交易合法性，这个集合的内容并没有写到区块链里。</p> <p>Merkle Proof可以证明某个交易存在于某个给定的区块中。假设存在一个轻节点，没有维护整个区块链的内容，只知道Block Header，那么他询问一个全节点，该交易是否在区块中，全节点可以返回一个Merkle Proof，作为证明，轻节点就可以验证这个是不是真的，可以验证全节点返回结果的正确性。如何证明某个账户A中有多少钱？全节点可以在本地的UTXO集合里算一下，即找到UTXO中所有转账给A的交易的输出一共有多少比特币，加在一起，就是A账户中一共有多少钱。但是，如果说像“比特币钱包”这样的APP，维护的是一个轻节点，想知道账户余额就要询问其他全节点，全节点返回一个结果，轻节点是没办法验证这个结果是否正确的。</p> <p>所以有人提议，将UTXO集合中的内容也组织成一共Merkle Tree，这个Merkle Tree有一个根哈希值，将这个根哈希值写在CoinBase域中，因为Block Header没办法再修改了，但是修改CoinBase域的内容，Block Header里的根哈希值也会跟着改，这样就可以根据Merkle Proof证出来正确性了。</p> <p>②P2SH（Pay to Script Hash）</p> <p>这个功能在最开始的比特币版本中是没有的，是后来通过软分叉的方式加进去的。交易的时候不是付给Public Key的哈希，而是付给RedeemScripts赎回脚本的哈希。具体原理：点这里。新节点需要验证第一阶段和第二阶段均合法，而旧节点只需要验证第一阶段合法，所以说旧节点认为合法的交易，新节点不一定认为是合法的；但是，新节点认为是合法的交易，旧节点一定认为是合法的。</p></li> <li><p>总结</p> <p>软分叉特点：只要系统中半数以上算力的节点更新了软件，就不会出现永久性的分叉。</p> <p>硬分叉特点：只有当系统中所有算力的节点都更新了软件，才不会出现永久性的分叉，如果有少部分节点不愿意更新，系统则会分成两条链。</p></li></ul> <h2 id="问答"><a href="#问答" class="header-anchor">#</a> 问答</h2> <h3 id="转账交易如果接收者不在线-怎么办"><a href="#转账交易如果接收者不在线-怎么办" class="header-anchor">#</a> 转账交易如果接收者不在线，怎么办？</h3> <p>单纯的转账交易不需要接收者在线，转账交易只不过需要在区块链上记录一下，把A账户上的比特币转到B的账户上，与接收者是否连在比特币网络中无关。</p> <h3 id="假设某个全节点收到了转账交易-有没有可能转账交易中接收者的收款地址是这个全节点以前从未听说过的"><a href="#假设某个全节点收到了转账交易-有没有可能转账交易中接收者的收款地址是这个全节点以前从未听说过的" class="header-anchor">#</a> 假设某个全节点收到了转账交易，有没有可能转账交易中接收者的收款地址是这个全节点以前从未听说过的？</h3> <p>这是有可能的。比特币系统中，账户创建的时候是不需要通知其他人的，只需要在本地产生一个公私钥对就可以了。只有在以后，该账户产生的收款地址收到钱的时候，其他节点才会知道该账户的存在。</p> <h3 id="如果账户的私钥丢失了-该怎么办"><a href="#如果账户的私钥丢失了-该怎么办" class="header-anchor">#</a> 如果账户的私钥丢失了，该怎么办？</h3> <p>其实是没有办法的，账户上的钱就变成了死钱，是没有办法取出来的。比特币系统是去中心化的系统，是没有人可以帮你重置密码的。</p> <p>有些加密货币是有交易所的，交易所是一个中心化的机构，一般来说，在交易所注册账户时，需要提供身份证。这种情况下，将比特币保存在交易所里，私钥实际上是由交易所保管的。登录交易所跟登录银行账户的操作类似，一般需要用户名、口令和二次验证消息（如Google身份验证器生成的一次性密码），在这种情况下，如果登录口令丢失，可以联系交易所，通过身份验证后重置密码。</p> <p>上述这种丢失口令的情况跟比特币系统中丢失私钥的情况是很不一样的。比特币系统中虽然也存在一些能够帮忙保管私钥的应用，如比特币钱包等。但是，并不能说明这些应用保管私钥会比私人保存更安全。历史上发生过很多次加密货币的交易所被黑的情况，黑客从里面偷到了大量加密货币。其中最著名的是Mr. Gox的例子，这个曾经是世界上最大的比特币交易所，交易量达到了全球比特币交易量的70%，后来被 黑客攻击，丢失了大量的比特币，这个交易所后来破产了，其CEO被判刑。而且这种情况并非个例，各种加密货币交易所出现问题的情况发生过很多次，也有监守自盗的情况，有的工作人员、管理层人员卷款跑路的情况也都发生过。相比之下，有些冷钱包或者说硬件钱包是比较安全的。
私钥丢失之后，那么这些比特币将会永远花不出去，但矿工并不知道这个账户的私钥已经丢失了，这些比特币是取不出来的，所以他需要永远把交易的输出保存在UTXO中，这个操作对全节点是不友好的。</p> <h3 id="_4-如果私钥泄露了-怎么办"><a href="#_4-如果私钥泄露了-怎么办" class="header-anchor">#</a> （4）如果私钥泄露了，怎么办？</h3> <p>尽快把这个账户上的钱转到其他安全账户上。因为区块链是去中心化的，所以没有人能够充当“银行”的角色帮你冻结账户或者重置密码。账户创建的时候会在本地创建一对公私钥对，私钥就是这个时候产生的，公私钥对一旦生成无法修改。可以生成新账户，但是原账户的私钥无法修改，账户的持有者也没办法阻止他人发布从该账户转账的交易，任何有私钥的人都可以发布转账交易，把账户里的比特币转走。</p> <p>问：用户持有者如何知道自己的私钥泄露了，是否看见从该账户上转出的非本人发起的交易才能知道？</p> <h3 id="_5-如果转账时写错了地址-该怎么办"><a href="#_5-如果转账时写错了地址-该怎么办" class="header-anchor">#</a> （5）如果转账时写错了地址，该怎么办？</h3> <p>转账时，本来需要把比特币转给A，结果写错了A的地址，错将比特币转入了B的账户。这时我们是没有办法取消已经发布的交易的，比特币系统中一旦交易发布到区块上就没办法取消了，在比特币系统中没有提供一些能取消已经发布交易的机制。如果转账转到错误的地址，若知道地址归属于某账户（如B）的话，可以跟对方联系，看对方是否愿意把比特币还给你，但是这种情况也只能与对方商量，这个没有办法强迫。如果不知道转入地址归属哪个账户，或者转入地址是一个不存在的地址，就没有办法了。（这里个人感觉效果类似充话费的时候输错的电话号码）</p> <p>地址一般是该账户公钥取哈希值得到的，但是有些地址其实并不是取公钥的哈希得到的，如Digital Commitment。如果想要把某项内容发布在区块上，证明在某个时间知道某个事情，这里有一种比较经典的方法就是Proof of Burn，就是将需要发布的内容的哈希值存放在OP_RETURN后面。但是有的人不这么做，他用哈希值生成一个像是比特币地址的东西，来代替比特币的转账交易接收方的地址的内容。就比如说正常实现转账交易A→B，这里B表示账户公钥取哈希值得到的地址，但是如果用其他哈希值来代替接收方的地址的内容，比特币系统并不知道这个地址是真的还是假的，这样转账的比特币就成了死钱，是取不出来的。这种虽然也达到了牺牲一点比特币，往比特币中写入一点东西的效果，类似于Proof of Burn，但是这种做法是很不提倡的，因为这样的交易的输出将会永远被写在UTXO集合中，全节点收到这样的转账交易，并不能判断这个交易的地址是否为真，不知道这个转账交易是花不出去的，这个操作对全节点是不友好的。</p> <p>在Proof of Burn的情况下，OP_RETURN后的结果是无条件返回错误，不满足合法区块才会被写入区块中的条件，那么为什么还会用这种方式来向区块链中写入内容呢？验证的时候是将这个交易的输入脚本与前一个交易的输出脚本拼在一起运行，顺利执行就是合法交易。而在Proof of Burn的情况下OP_RETURN是写在输出脚本中的，所以验证这个交易合法性的时候并不会执行到OP_RETURN，也就不会返回错误。如果后面再有一笔交易想要花这笔交易里的钱的时候，才需要验证这个交易的输出脚本。所以判断交易是否合法，能否写入区块的时候，并不会执行到OP_RETURN部分。</p> <h3 id="_6-比特币挖矿的实质是在找合适的nonce-看看哪个nonce符合难度要求。那么会不会有矿工-偷答案-如-他自己没有找到合适的nonce-其他矿工发布nonce-他看到区块之后-查了一下这个nonce是符合要求的-他就将这个作为自己找到的nonce发布出去。如何辨别是哪个矿工最前找到的这个nonce"><a href="#_6-比特币挖矿的实质是在找合适的nonce-看看哪个nonce符合难度要求。那么会不会有矿工-偷答案-如-他自己没有找到合适的nonce-其他矿工发布nonce-他看到区块之后-查了一下这个nonce是符合要求的-他就将这个作为自己找到的nonce发布出去。如何辨别是哪个矿工最前找到的这个nonce" class="header-anchor">#</a> （6）比特币挖矿的实质是在找合适的Nonce，看看哪个Nonce符合难度要求。那么会不会有矿工“偷答案”，如，他自己没有找到合适的Nonce，其他矿工发布Nonce，他看到区块之后，查了一下这个Nonce是符合要求的，他就将这个作为自己找到的Nonce发布出去。如何辨别是哪个矿工最前找到的这个Nonce？</h3> <p>发布的区块里面有个CoinBase Transaction，里面有个收款人地址，是挖到矿的矿工的地址。如果要“偷答案”，需要将收款人的地址改为自己的地址，那么这个CoinBase Transaction的内容将会发生改变，这样会导致Merkel Tree的根哈希值会发生变化。Nonce在块头中，根哈希值也在块头中，Block Header的值发生变化之后，原来找到的Nonce就作废了。</p> <h3 id="_7-问-如果要是挖到矿的矿工与偷答案的矿工同属于一个矿场呢"><a href="#_7-问-如果要是挖到矿的矿工与偷答案的矿工同属于一个矿场呢" class="header-anchor">#</a> （7）问：如果要是挖到矿的矿工与偷答案的矿工同属于一个矿场呢？</h3> <p>交易费可以看作是发布一个交易的时候给矿工的一点小费，那么如何知道这个交易费给哪个矿工，如何事先知道哪个矿工会挖到矿？
事先不需要知道哪个矿工会挖到矿。交易费的计算是total inputs - total outputs，即总输入与总输出的差值，哪个矿工先挖到矿了不需要事先知道，挖到矿的矿工可以将区块中所包含交易发输入与输出的差额收集起来，作为他自己的交易费。</p> <h2 id="btc-匿名性"><a href="#btc-匿名性" class="header-anchor">#</a> BTC 匿名性</h2> <h3 id="btc匿名性"><a href="#btc匿名性" class="header-anchor">#</a> BTC匿名性</h3> <ul><li><p>什么是BTC匿名性</p> <p>匿名性是跟Privacy联系在一起的，所谓Privacy就是说你做的某件事情，不希望别人知道的情况。比特币系统中不要求用真实姓名，可以使用公钥产生的地址，所以从这一特点上说，比特币系统具有一定程度的匿名性。一个用户可以产生任意多的地址，然后用不同的地址做不同的事情。但是BTC也并不是说完全没有名字，它用的是化名，所以有人认为，BTC中的匿名性叫做Pseudonymity（假名字）。</p></li> <li><p>BTC的匿名性可以提供哪些隐私保护</p> <p>BTC的匿名性没有现金好，现金是完全匿名的，其缺点是不方便保管和运输。比特币系统的匿名性显然比银行存款要好，因为现在的银行账户是实名制的。如果银行用化名的话（存钱提供化名即可，取钱的时候拿着存折取钱），其匿名性会优于比特币，因为比特币账本是公开的，所有人都可以查到，而银行的账本是受控制的，一般只有银行工作人员和一些司法机关可以查到银行的账本。</p></li> <li><p>比特币系统中在什么情况下有可能破坏匿名性
①一个人可能生成很多个地址账户，但是这些地址账户是有可能被关联起来的。</p> <p>有的人推荐每次收款都生成不同的公私钥对，每次都用不同地址交易，他们认为如果这样做的话，匿名性会非常高。但是其实适得其反，因为我们可以用一些手段将这些交易关联在一起。假设存在如下图所示的交易，该交易存在两个输入和两个输出，那么addr1和addr2很可能是同一个人所持有的账户，此人同时拥有这两个私钥的地址，这种情况可能是此人持有的一个账户中的比特币可能不够支付这次交易而导致的。而在输出中，很有可能有一个地址是属于找零钱的地址，即花掉之后剩余的钱。在某些情况下，也是可以分析出来的。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/099901ecb9ad4a2bb561bdcca402e488.png" alt="img"></p> <p>假设，我们将上面的例子具体化，如图所示。我们很容易分析出add4属于找零地址，因为如果add4不是找零地址的话，Input只需要一个就够了，不需要两个Input。从这个角度上来说，就可以将输入地址和输出地址关联起来。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/e9153a51fc6548ff8ac61a33a9fde3eb.png" alt="img"></p> <p>从理论上讨论，如果想要加强隐私保护，可以人为产生很多没必要的输出，迷惑敌人。但是这些交易都是用钱包软件生成的，常用的比特币钱包就那么几种，所以如果将比特币钱包生成交易的原理，那么区块链上很大一部分转账交易都可以分析出来，常用钱包目前为止不会生成没必要的输出地址。</p> <p>②BTC中的地址账户与账户持有者在现实社会中的真实身份也可能产生关联。</p> <p>任何让虚拟货币跟实体世界发生联系的操作，都可能跟真实身份产生关联。这里面最典型的是资金的转入和转出。比如，A去交易所购买比特币，交易所一般需要登记注册，这时候就需要A的身份信息。也有可能有场外交易，如A像B购买比特币的操作，场外交易中，直接交易的人也有可能泄露你的身份信息。</p> <p>在很多国家，都有防洗钱法。如何防范不法分子采用比特币进行洗钱呢？其实很简单，只需要盯住资金转入转出链即可。对于大额资金转入比特币或将大量比特币转为现实货币，很难逃避司法金融机构的监管。这也是比特币匿名性被破坏的很重要的例子。</p> <p>③在实体世界中，用BTC做支付的时候。</p> <p>国外有的商家接收比特币支付，如咖啡厅、餐厅等。但是这可能不是一个good idea，因为用比特币交易延迟高，交易费贵。在这种情况下，也是可能对比特币的匿名性造成破坏的。因为这就相当于一个账户会参与很多交易，比较容易把这些交易信息关联起来，从而破坏匿名性。其实不光接受支付的商家会知道，其他人也会知道。</p> <p>曾经有一家信用卡交易中心，为了支持学术研究，将它收到的信用卡交易记录公开了（公开的时候删除了姓名、年龄等信息，并将信用卡号码取哈希值，让人们知道哪些交易是同一个人做的，而不知道这个人的具体信息），然后就有人做了个研究，证明如何通过这些公开信息推测出一个人的身份信息，证明这种方式不可取。可以根据定位消费定时消费的行为，从实体世界获得数据，从而过滤一部分信息，过滤几次之后，也就可以获得某个人的信息了。</p> <p>从这个例子中，我们可以得到，信用卡交易信息即使进行保密处理之后，依然不能公开。但比特币系统中的交易信息都是公开的，如果去咖啡店买咖啡，不光是与你发生交易的人知道了你的信息，周围其他人有认识你的，你在这个时候在用比特币进行了一笔消费，然后到区块上去查，区块链上有哪些账户在此时进行了消费，从而就能推算出哪些账户可能是你。这么一两次之后，很快就能确认哪个是你了。</p></li> <li><p>实际当中BTC的匿名性</p> <p>从刚才的例子中可以得知，BTC的匿名性是相对的。在实际中，也有很多人保持有较好的匿名性。保持最好的当属其开发者中本聪，其参与比特币时间最长，但是全世界都不知道他是谁。但实际上，中本聪的比特币并非有花出去，这也使得我们难以发现他具体是谁。</p> <p>曾经美国有一个skil road网站，被称为eBay for illegal drugs，主要用于匿名支付售卖违禁品，为了逃离网络监管，其支付手段就是比特币，底层的网络层是洋葱路由TOR。但运行没有几年就被查封，其老板当时赚取了十几万比特币，从纸面上看，已经非常有钱了。但由于其担心身份暴露，这些钱一个都不敢花，在美国仍然过的是非常简朴的生活。最终据说由于疏忽，在同一电脑上登录现实社会账户和非法网站上账户，从而被抓(具体原因未公开)。
skil road被查封后，有人开通了skil road2，运行没有几年又被查封。依次可知，比特币的匿名性并非我们想象那么好，互联网并非法外之地，如果想利用比特币从事违法活动，基本都被逮捕了。中本聪为何能保持如此好的匿名性，属于个例，首先他并没有做出违法乱纪的事情，还有就是因为在比特币走上正轨之后，他就功成身退消失了，这也是他到现在也没有泄露身份的原因。</p></li> <li><p>BTC匿名性有多好？
匿名的本质是不想要暴露身份，但是它区别于你是想对谁隐瞒身份。而对于普通人来说，比特币的现有机制已经足够保持个人隐私了。但如果涉及违法，行政机关想要获得真实身份，其实很容易。</p></li> <li><p>如何提高匿名性？
比特币协议实际上是运行在应用层的，其底层实际上是P2P Overlay Network。提高匿名性就要从这两个层面来提高。如果不保证网络层的匿名性，其他结点发现这个交易都是单一路径（同一个IP地址）发布，其他结点很可能通过这一路径推测其在物理世界中的真实身份。</p> <p>网络层的匿名性学术界已经有了很好的解决方法：采用多路径转发的方法，数据不直接发送出去，而是经过很多跳（中间结点只知道它的上一层结点是谁，并不知道最开始发送消息的人是谁）这也是洋葱路由的基本思想。</p> <p>应用层的匿名性，可以将各个不同用户的比特币混合在一起，使追查变得混乱，这种方法就是Coin Mixing。①有一些专门做Coin Mixing的网站，他们的做法是将想要在他们这里做Coin Mixing的人的币，内部做一些重组，然后再让这些人取回，取回的币一般情况下不是发出的币。问题在于，当前并没有一些信用比较高的做Coin Mixing的网站，他们存在卷钱跑路的情况，而且出了这样的问题也是没办法挽回的。②不用特意去做Coin Mixing，有一些应用，这些应用带有做Coin Mixing的功能，如在线钱包（可能有）或加密货币交易所（天然有）等。</p> <p>实际上，暴露用户隐私正是由于区块链的公开性和不可篡改性。实际上，不可篡改性对于隐私保护，是灾难性的，因为一旦某一个交易不小心把身份暴露出去了，这个交易永久的写在区块链里，想抹掉都不能，所以说账户之间的关联性是需要小心的。</p></li></ul> <h3 id="零知识证明"><a href="#零知识证明" class="header-anchor">#</a> 零知识证明</h3> <ul><li><p>什么是零知识证明</p> <p>零知识证明是指一方（证明者）向另一方（验证者）证明某一个陈述是正确的，而不需要透露除该陈述是正确的之外的任何信息。如，A是比特币账户时他的。该比特币账户属于A，说明A知道该账户的私钥，但是A又不能把私钥告诉别人，这就可以用签名的方法：A使用这个私钥进行的签名，假设对方知道公钥，就可以用公钥验证这个私钥的正确性。这个证明是不是零知识证明其实是有争议的，因为A虽然没有直接透露这个私钥，但是他透露了由该私钥进行的签名，这与“不需要透露除该陈述是正确的之外的任何信息”有一定出入。这个在实际生活中要根据实际的应用场景，具体情况进行分析。</p></li> <li><p>同态隐藏</p> <p>同态隐藏是零知识证明的数学基础，其三个性质如下：</p> <ul><li><p>如果x，y不同，那么它们的加密函数值 E(x) 和 E(y) 也不相同。（说明这个加密函数值E不会发生碰撞，与哈希函数不同，哈希函数有可能会出现碰撞，这里的加密函数值不会发生碰撞。若 x ≠ y，那么E(x) ≠ E(y)。如果E(x) ＝ E(y)，则x = y。）</p></li> <li><p>给定 E(x) 的值，很难反推出x的值。（说明加密函数是不可逆的，知道加密函数值，无法反推出原来输入的值。这里的性质与比特币系统的Hiding Property类似。）</p></li> <li><p>给定 E(x) 和 E(y) 的值，我们可以很容易计算出某些关于x，y的加密函数值。（同态运算，说明对加密后的函数值进行某些代数运算，等价于对输入直接进行代数运算再加密。）
①同态加法：通过 E(x) 和 E(y) 计算出 E(x+y)  的值。
②同态乘法：通过 E(x) 和 E(y) 计算出 E(xy) 的值。
③扩展到多项式。</p> <blockquote><p>例：Alice想要向Bob证明她知道一组数x 和 y 使得x + y = 7，同时不让Bob知道x 和 y 的具体数值。</p> <p>①Alice把 E(x) 和 E(y) 的数值发给Bob
②Bob通过收到的 E(x) 和 E(y) ，计算出 E(x+y)  的值
③Bob同时计算 E(7) 的值，如果 E(x+y) = E(7)，说明x+y = 7，那么验证通过，否则验证失败。</p></blockquote></li></ul></li> <li><p>盲签方法</p> <ul><li>用户A提供SerialNum（货币编号），银行在不知道SerialNum的情况下返回签名Token（银行签名的时候看不见序号的内容），减少A的存款；</li> <li>用户A把SerialNum和Token交给B完成交易；</li> <li>用户B拿SerialNum（明文）和Token给银行验证，银行验证通过，增加B的存款；（银行要记录该序号是否存在Double Spending）</li></ul> <p>这样做的好处是银行无法把A和B联系起来；而且实现了中心化。</p></li> <li><p>零币和零钞——专门为匿名性设计的加密货币</p> <ul><li><p>零币和零钞在协议层就融合了匿名化处理，其匿名属性来自密码学保证。</p></li> <li><p>零币(zerocoin)系统中存在基础币（如比特币）和零币，通过基础币和零币的来回转换，消除就地址和新地址的关联性，其原理类似于混币服务。</p></li> <li><p>零钞(zerocash)系统使用zk-SNARKs协议，不依赖一种基础币，区块链中只记录交易的存在性和矿工用来验证系统正常运行所需要关键属性的证明。区块链上既不显示交易地址也不显示交易金额，所有交易通过零知识验证的方式进行。</p> <p>零币和零钞在花费的时候，只需要用零知识证明来证明所花掉的币是系统中存在的某一个合法的币，但不用透露具体花掉的是系统中哪一个币。这样就破坏了关联性。但这类货币并非主流加密货币，原因如下：①其为了设计匿名性，付出了一定代价；②在数学原理上对初始化有比较严格的要求（即初始时候用的随机元要能销毁掉，如果不能销毁则会出现安全漏洞）；③需要强匿名性的用户并不多；④虽然从数学上看，零币和零钞是安全的，但其并不是百分之百的匿名，并未解决与系统外部实体发生交互时对匿名性的破坏。</p></li></ul></li></ul> <h2 id="btc-思考"><a href="#btc-思考" class="header-anchor">#</a> BTC 思考</h2> <h3 id="哈希指针"><a href="#哈希指针" class="header-anchor">#</a> 哈希指针</h3> <p>BTC在设计的过程中很多地方用到了哈希指针，如块头就包含指向前一个区块的哈希指针，指针保存的是本地内存的地址，只在这台计算机上才有意义，发送到其他计算机上就没有意义了，那么在发布区块的时候哈希指针是如何通过网络传输的呢？
实际上，在BTC系统中，所谓哈希指针只是一种形象的说法，实际在用的时候，其实只有哈希，没有指针。回顾之前学习过的Block Header的数据结构，如下所示，我们可以得知， <code>uint256 hashPrevBlock</code>；这里表示的就是前一个区块的哈希，实际上是没有指针的。</p> <div class="language-c extra-class"><pre class="language-c"><code>class CBlockHeader
<span class="token punctuation">{</span>
public<span class="token operator">:</span>
	<span class="token comment">//header</span>
	<span class="token class-name">int32_t</span> nVersion<span class="token punctuation">;</span><span class="token comment">//当前使用的比特币协议的版本号，没法修改（4字节）</span>
    uint256 hashPrevBlock<span class="token punctuation">;</span><span class="token comment">//前一个区块块头哈希值（32字节），不能修改</span>
    uint256 hashMerkleRoot<span class="token punctuation">;</span><span class="token comment">//Merkle Tree的根哈希值（32字节）；</span>
                  <span class="token comment">//通过修改Merkle Tree中铸币交易的CoinBase域当作ExtraNonce来调整其根哈希值</span>
    <span class="token class-name">uint32_t</span> nTime<span class="token punctuation">;</span><span class="token comment">//区块产生时间，有一定调整余地（4字节）；</span>
                    <span class="token comment">//比特币系统并不要求非常精确的时间，这个时间可以在一定范围内调整</span>
    <span class="token class-name">uint32_t</span> nBits<span class="token punctuation">;</span><span class="token comment">//挖矿后的目标阈值编码后的版本（4字节）;</span>
                    <span class="token comment">//只能按照协议中的要求定期进行调整，不能随便改</span>
    <span class="token class-name">uint32_t</span> nNonce<span class="token punctuation">;</span><span class="token comment">//（4字节）单纯靠调整nonce的值很大概率找不到符合难度要求的</span>
<span class="token punctuation">}</span>

</code></pre></div><p>那么，如何找到前一个区块的内容呢？ 全结点一般是将这些区块存储在一个 (Key,Value) 数据库中，Key表示哈希值，Value表示区块的内容，有一个比较常用的 (Key,Value) 数据库——LevelDB。所谓的区块链是一个链表结构，实际上是在 LevelDB 里面，用哈希值串起来的。只要掌握最后一个区块的哈希值，用 LevelDB 查找 (Key,Value) ，就可以通过哈希值Key得到Value，就可以把最后一个区块的内容取出来。然后这个区块的Block Header里面又有指向前一个区块的哈希值，然后再去用 LevelDB 查找 (Key,Value) ，就可以找到前一个区块的内容，以此类推，就可以把整条区块链都找出来。
  所以，在实际系统之中，所谓的哈希指针是只有哈希没有指针的，或者也可以认为哈希值本身就是指针。有些结点没有保存区块链整条链上的全部信息，只保存了最近的几千个区块的信息，如果需要用到前面区块的信息，可以问其他全结点要，哈希指针的性质保证整个区块链是不可篡改的。</p> <h3 id="区块恋可能造成的问题"><a href="#区块恋可能造成的问题" class="header-anchor">#</a> 区块恋可能造成的问题</h3> <p>据说曾经在七夕的时候，有一些情侣，两个人合在一起买比特币，然后将私钥从中间截断，分成两部分，每人保存其中的一段，将来如果两个人的关系继续，两段私钥合在一起就可以把钱取出来，如果两个人分手了，当初买的比特币就被永久地所在区块链上，谁也取不出来。这种情况叫“区块恋”，用区块的不可篡改性作为两人爱情的见证。
可能造成的问题：
①如果有一个人把私钥丢失（或遗忘），都会导致比特币无法取出。
这种做法如果被推广下去的话是存在很大问题的，假设一个公司有四个商户，将私钥切成四份，一人保管其中一份，一个比较显然的问题是四个人中如果有一个人把私钥丢失（或遗忘），都会导致比特币无法取出。
②这种做法还会产生一个更大的问题：降低账户的安全性。
比特币系统中账户的安全性跟用户所用的私钥的长度是相关的，用256位的私钥就是因为这个长度的私钥用暴力破解的方式是不可行的，但是如果从中截断，就会大大降低其安全性。
回到“区块恋”的例子，假设情侣两人分手，其中一个人想要把比特币取出来，他已经拥有一半的私钥，那么只需要破解另外一半就可以，破解长度为256的私钥需要尝试的可能性为2256，而破解128位的私钥需要尝试的可能性为2128，是指数级的减小。在上面提到合伙人 例子中，如果有三个合伙人串通起来想要背着另一个人把比特币取出来，他们需要尝试的次数仅为256。
所以说对于多个人共同持有的账户，不能用私钥截断的方式，而应该使用多重签名的方式来保障安全性。 在多重签名（MULITISIG）中，每个人用到的私钥都是独立产生的，而且多重签名还具有很多灵活性，如N个人中只给出M个人的签名就可以验证通过。
③取不出来的钱将会永久被存在UTXO集合中，对矿工是不友好的。
假设“区块恋”的例子中的两个情侣分手，不存在其中有人有使用暴力手段破解私钥的情况，那么这些比特币将会永远花不出去，矿工并不知道这对情侣已经分手了，这些比特币是取不出来的，所以他需要永远把钱保存在UTXO中，这个操作对全结点是不友好的。</p> <h3 id="理论上-分布式共识是不可能的-为什么它能绕过分布式系统理论上证明的那些不可能结论"><a href="#理论上-分布式共识是不可能的-为什么它能绕过分布式系统理论上证明的那些不可能结论" class="header-anchor">#</a> 理论上，分布式共识是不可能的，为什么它能绕过分布式系统理论上证明的那些不可能结论？</h3> <p>我们之前学习过比特币的共识协议，了解过分布式系统比较著名的不可能结论，从理论上证明，分布式系统中取得共识是不可能的，那么既然理论上已经证明了是不可能的，实际上为什么又变得可能了呢？就是说比特币系统为什么能取得共识，为什么它能绕过分布式系统理论上证明的那些不可能结论？
严格意义上说，比特币系统并没有真正意义上的共识，因为取得的共识随时都有可能被推翻，如出现分叉攻击（本来你以为已经取得某项共识，分叉攻击之后，系统会回滚到前一个状态，从理论上说甚至有可能一直回滚到创世纪块），按照分布式系统理论上的要求，共识一旦达成就不应该再修改。从这个意义上说，比特币系统并没有绕过分布式系统那些不可能的结论，因为它并没有达到真正意义上的共识。理论和实际往往是有距离的，理论上的不可能只是在某种特定的模型下是不可能的，实际上把模型稍微改一改，这个不可能结论就不成立了。
如何判断远程数据中心的一台服务器是不是已经死机了。专家的看法是：分布式系统的理论已经证明了，在异步环境中，不可能区分某个远程服务器到底是死机还是运行缓慢。（所谓的异步环境是指通讯传播的延迟是没有上限的）但是实际上，我们可以给远程服务器的工作人员打个电话，让他们看看这个服务器是不是死机了，如果死机帮忙重启一下，这样下来，这个理论上不可行的案例，实际上就变成可行的了。或者给服务器加一根电话线，进行拨号上网，如果发现Internet执行缓慢可以试一下电话线，两根线一般不会出现同时拥堵的情况，这样就可以确认远程服务器是否死机。</p> <blockquote><p>“不要被学术化的思维限制了头脑。”</p></blockquote> <h3 id="btc稀缺性"><a href="#btc稀缺性" class="header-anchor">#</a> BTC稀缺性</h3> <p>BTC系统中的矿工为什么要挖矿？为了获得收益，挖矿的收益大于挖矿的开销，才是有利可图的。所以，想要吸引到更多人来挖矿，要么增加挖矿的预期收益，要么降低挖矿的开销。比特币诞生之初，挖矿的难度较低而且挖矿奖励比较高（50BTC），吸引大家来挖矿。
BTC的设计是非常巧妙的，我们之前计算过，每过大约四年时间，出块奖励会减半一次，也就是说比特币的总数是恒定的。有些人说这种总量恒定的东西是不适合作为货币的，以太坊就没有出块奖励定期减半的做法，有些加密货币甚至每过一段时间会自行通胀一次，因为稀缺的东西是不适合做货币的。
例如，古代使用黄金作为货币，但是放到现在就很不合适了，因为现在黄金的开采速度远远赶不上人们创造物质财富的速度，如果依然使用黄金做货币的话，就会造成一个现象：黄金越来越值钱，那么最开始拥有金子的人就不需要工作了，每天看着金子价格上涨就行，没有金子的人永远都不可能赶上之前那些人拥有的物质财富，这是非常不合适的。比特币最近几年的涨幅已经超过的北京的房价，如果感兴趣可以看看货币金融学方面的知识。</p> <h3 id="量子计算"><a href="#量子计算" class="header-anchor">#</a> 量子计算</h3> <p>最近几年量子计算发展很快，有人产生这样一种担心：比特币这种加密货币是建立在密码学的基础上的，将来量子计算技术发展起来以后，这些加密货币会不会变得不安全？
传说中的量子计算机是非常强大的，可以破解现存的各种加密算法，但是这个担心是不必要的。首先，量子计算机距离使用还有很长一段时间，虽然各种报道中说的它很厉害，但是距离实用还有很长时间，在比特币的有生之年不一定能产生实质性的威胁。而且，如果将来有一天量子计算真正强大到可以破坏现有的加密体系的话，首先受到冲击的是传统金融业，像网银、网上支付等等都会变得不安全。所以，与其担心量子计算对比特币的冲击还不如担心量子计算对传统金融业的冲击，因为大多数的钱都是存放在传统金融体系中的，加密货币的总市值现代金融体系的很少一部分，而且将来还会有量子加密算法。
第二，比特币系统中并没有把账户的公钥直接暴露出来，而是用公钥取哈希之后得到一个地址。BTC中用的是非对称加密体系，从私钥可以推导出公钥，所以只要将私钥保管好，公钥即使丢了也没有关系，公钥显然不能推出私钥。假设以后，量子技术发达了，可以通过公钥推到得到私钥，那么在比特币系统中，还需要突破另一层保护机制，就是需要能够从公钥的哈希推算出公钥，而这一点即使使用量子计算机也是无法完成的。加密跟取哈希是两种不同性质的操作，加密的目的是保证信息的安全性，以后还要解密，所以加密需要保证信息的完整性，加密过程不能丢失信息。而取哈希不一样，取哈希一般情况下会造成信息的损失，哈希函数一般都是不可逆的，从哈希值是无法得到原来的输入的。
比特币系统中哈希函数用的是SHA-256，即无论输入有多大，输出的都是256位的，这种情况如果可逆就会变成一个超级无敌的压缩算法。所以，如果仅用来收钱的情况下，不建议把公钥暴露在比特币系统上，收钱的时候只需要提供公钥的哈希提供的地址就可以，取钱的时候才需要提供公钥，取钱的交易中需要公钥和由私钥产生的签名。如果一个人想要偷A账户上的钱，他需要在A发布交易时实时破解从A的公钥推导出A的私钥，再实时产生一个跟A的交易竞争的交易。即使这个人具有量子计算技术也很难在几分钟之内就将私钥破解，而且他发布的交易还需要抢在A发布交易的前面，因为如果在A发布交易之后，就会产生Double Spending。所以从比特币安全的角度来看，比特币系统中每个账户只取一次钱，花不完的钱转给自己的其他账户，这样做既提升了安全性，也提高了隐私保护的程度。</p> <h1 id="以太坊"><a href="#以太坊" class="header-anchor">#</a> 以太坊</h1> <h2 id="eth-概述"><a href="#eth-概述" class="header-anchor">#</a> ETH 概述</h2> <h3 id="以太坊相较比特币做出的改进"><a href="#以太坊相较比特币做出的改进" class="header-anchor">#</a> 以太坊相较比特币做出的改进</h3> <p>比特币和以太坊是最主要的两种加密货币，比特币称为区块链1.0，以太坊称为区块链2.0。以太坊的设计过程中针对比特币设计中存在某些问题做出了改进。</p> <ul><li>出块时间：比特币的出块时间是十分钟，有些人认为这影响到了响应时间，以太坊的出块时间是十几秒，而且为了适应新的出块时间，以太坊还设计了一套基于GHOST协议的共识机制；</li> <li>Mining Puzzle：比特币的Mining Puzzle是计算密集型，比拼计算哈希值的算力，这样造成的结果是挖矿设备的专业化，多年以前用桌面机挖矿就是无利可图了，现在大家用的都是ASIC芯片，很多人认为这与区块链去中心化的理念相悖，以太坊设计的Mining Puzzle对内存要求高，在一定程度上限ASIC芯片（ASIC Resistance）的使用；</li> <li>用权益证明来替代工作量证明：工作量证明（Proof of Work）说白了就是挖矿，证明你为了发布区块之前做了很多工作，所以叫工作量证明。以太坊中改成了权益证明（Proof of Stake），这个时候就不挖矿了，改成了类似股份投票的方法，决定下一个区块怎么产生。</li></ul> <h3 id="以太坊增加的新功能"><a href="#以太坊增加的新功能" class="header-anchor">#</a> 以太坊增加的新功能</h3> <p>智能合约（Smart Contract）。BTC本身是一个去中心化的货币，在比特币取得成功之后，很多人就开始思考：除了货币之外，还有什么可以去中心化？以太坊的一个特性就是增加了对去中心化的合约的支持。比特币（BTC）最小计量单位是Satoshi（聪），以太坊（ETH）中的货币称为以太（Ether），最小计量单位是Wei。</p> <h3 id="去中心化的合约"><a href="#去中心化的合约" class="header-anchor">#</a> 去中心化的合约</h3> <p>货币本来是由政府发行的，货币的价值建立在政府公信力的基础上，政府通过司法手段维护货币体系的正常运行，比特币的出现用技术手段把政府这些职能取代，通过密码学的加密机制和共识机制来维护这个加密货币体系的正常运行。去中心化的合约也是类似的意思，现实社会中合约的有效性也是通过政府采取司法手段来维护的，使用技术手段把这些司法手段取代，就是智能合约的目的，如果合约中的内容是可以通过代码实现的，就可以将这样的代码放在区块链上，通过合约的不可篡改性保证代码正常运行。并非所有合同都能通过代码实现的，也不是所有合同条款都可以量化的，但是有些逻辑比较清晰的合同是可以写成智能合约的形式的。</p> <h3 id="去中心化的合约有什么好处"><a href="#去中心化的合约有什么好处" class="header-anchor">#</a> 去中心化的合约有什么好处？</h3> <p>首先，去中心化的货币有什么好处？比如跨国转账，用传统的方式就很麻烦，交易费非常昂贵而且转账时间非常长，用加密货币（如BTC）则方便很多。
那么，智能合约也有类似的应用场景，若合同签署方并非一个国家，来自世界各个国家，没有统一的司法部门，若此时想要利用司法手段来维护合同的有效性会比较麻烦，如：面向世界范围的众筹。这种情况下，如果通过事先写好的程序代码来保证每个人只能按照这样的规则来执行，这是一种比较好的解决方式。其实，就算合同的参与方都是在同一个司法管辖权之下的，真正想要通过司法手段维护合同的执行也是比较费时费力的过程。所以，用技术手段编写无法修改的合约，所有人只能按照相关参与方执行，无法违约，这是最好的。</p> <h2 id="eth-账户"><a href="#eth-账户" class="header-anchor">#</a> ETH 账户</h2> <h3 id="比特币的账户模式"><a href="#比特币的账户模式" class="header-anchor">#</a> 比特币的账户模式</h3> <p>比特币系统是基于交易的账本（Transaction Based Ledger），系统中并未显示记录每个账户上有多少钱，只能通过UTXO进行推算（即在UTXO中查找该账户公钥有多少输入即可）。这种方式的好处是隐私保护比较好，你有多少钱，自己可能都说不清，别人就更不知道了。但实际中，使用起来比较别扭。
假设A转给B钱的时候，需要说明币的来源。这跟日常生活中的体验是不一样的，日常生活中，只有去银行存钱说明来源，花钱则不用说明每一笔钱的来源。此外，比特币账户中，在前面一笔交易中收到的比特币，在花的时候必须一次性全部花出去，不能只花一部分。
回到之前的例子用户A获得了铸币权，假定A发行了10个比特币后，将这10个比特币分别转给B和C，每个人分得5个比特币，这里就需要说明A转给B和C的比特币来自于他发起的铸币交易。接下来用户B给用户C分2个比特币，给用户D分3个比特币，C将自己的7个比特币全部给用户E，这些交易也都一样，需要说明自己花掉的比特币来自于哪个交易，如图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/0eba2533c5ec4dbca800fd626f7129a9.png" alt="图1-1"></p> <p>假设B收到A的5个比特币，他想要给C转账2个比特币，不给D转账其余3个比特币，如果按照图中方式，其余3个比特币会以交易费（Transaction Fee）的形式给挖出区块的矿工。因此，为了避免这种情况，所以采用2中方式，将3个BTC转给C，将剩余7个BTC转到B的另一账户D上面。很多比特币钱包就采用这种方式，每次转账就生成一个自己的新的地址，有利于隐私保护，但是仍然与日常生活有所不同。这是因为比特币系统中没有显示的基于账户的交易的概念，在比特币系统中，每个交易是单独进行处理的。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/81b8183f93c8418eb7ab609dd066689f.png" alt="图1-1"></p> <h3 id="以太坊的账户模式"><a href="#以太坊的账户模式" class="header-anchor">#</a> 以太坊的账户模式</h3> <p>以太坊系统则采用了基于账户的模型，与现实中银行账户相似。系统中显示记录每个账户中以太币的数量，转账是否合法只需要查看转账者账户中以太币是否足够即可，不用确切指出转出的钱属于哪一部分，同时也不需要每次全部转账，如图所示。同时，这也也天然地防范了双花攻击。因为如果出现Double Spending，不需要像比特币一样说明币的来源，只需要扣两次钱就好了。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/cf49afb7d58c4bf38e07f23333f822f0.png" alt="img"></p> <p>当然，以太坊发这种模式也存在缺点，这种模式存在重放攻击（Reply Attack）的缺陷。A向B转账10个ETH，过一段时间，B将A的交易重新发布，从而导致A账户被扣钱两次。双花攻击和重放攻击是相对的，双花攻击说的是花钱的人不诚实，花过的钱继续花一次，重放攻击说的是收钱的人不诚实，收到过的钱再继续收一次。 在比特币中会有重放攻击吗？不会，因为收到过的交易信息再广播一次是很显然的Double Spending。
以太坊中，解决重放攻击的方法也非常简单，在每笔交易中添加一个Nonce，记录该账户有史以来一共发布多少交易，转账时，Nonce作为交易的一部分，同时受到签名的保护，从而防止本地篡改余额或进行重放攻击。如下图所示，A给B转账10个ETH，转账次数是21，所有全节点会维护这样一个状态数，假设过了一段时间之后，B重放了这个交易，其他节点查到A账户的转账数已经到23了，那么自然会发现这个被重放的交易是不合法的。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/e3133eff69de472b85182c9e6f45859d.png" alt="img"></p> <p>（3）以太坊的账户类型</p> <ul><li>外部账户：类似于比特币系统中的账户，是用公私钥对控制的。本地产生公私钥对，谁拥有公私钥对，就掌握账户控制权。外部账户中有账户余额Balance和计数器Nonce（这里注意要跟挖矿调整的Nonce区分）。</li> <li>合约账户：并非通过公私钥对控制。合约账户不能主动发起交易，若外部账户发起交易调动了一个合约账户，该合约账户可以发起一个Message调用另外一个合约，但是不能自己主动发起交易。合约账户除了Balance和Nonce之外还有代码(Code)、相关状态-存储(Storage)，包括每个变量的取值。</li></ul> <p>创建合约时候会返回一个地址，知道这个地址就可以调用这个合约。调用过程中，代码不变但状态会发生改变，存储也会发生变化。</p> <p>（4）为什么创建以太坊，更换为基于账户的模型而不是沿袭比特币系统？
比特币基于交易的模型隐私保护比较好，每次交易支持更换账户，而以太坊是为了支持智能合约，对于合约来说，要求参与方的身份较为稳定。比如，现在有人提出将智能合约用于金融衍生品（Financial Derivative），如期货等。所以，对于账户来说，不希望其身份发生改变，对于合约账户来说，如果地址变了，那投入到原来合约的钱也就找不见了。以太坊系统则采用了基于账户的模型，其账户是希望保持稳定的，不论是合约账户还是外部账户，当然如果有隐私保护的需要，同样可以创建很多个账户，根据需要使用不同的账户进行交易。</p> <h2 id="eth-状态树"><a href="#eth-状态树" class="header-anchor">#</a> ETH 状态树</h2> <h3 id="以太坊中的状态树"><a href="#以太坊中的状态树" class="header-anchor">#</a> 以太坊中的状态树</h3> <p>以太坊中采用的是一种基于账户的模式，系统中显示地维护每个账户上有多少余额，接下来我们了解一下这种基于账户的模式是如何实现的？想要实现这种模式需要完成从账户地址（Address）到账户状态（State）的映射。以太坊中的账户地址是160位的，也就是20字节，一般将其表示为40个十六进制的数。状态是指外部账户和合约账户的状态，包括余额，交易次数Nonce，对于合约账户还包括代码和存储。</p> <h3 id="实现从账户地址到账户状态的映射"><a href="#实现从账户地址到账户状态的映射" class="header-anchor">#</a> 实现从账户地址到账户状态的映射</h3> <ul><li><p>哈希表+Merkle tree</p> <p>用哈希表实现，系统中的全节点维护一个哈希表，每次有一个新的账户，插入到哈希表里面，查询账户的余额，就直接在哈希表中查询，如果不考虑哈希碰撞的话，基本上查询的效率是在常数时间内完成的，更新也是很容易在哈希表中更新的。</p> <p>如果用这个哈希表要提供merkle proof怎么提供？比如说你要跟一个人签合同，希望他能证明一下他有多少钱，怎么提供证明呢？一种方法是类似比特币系统中的做法，把哈希表中的元素组织成一个Merkle Tree，然后算出一个根哈希值，这个根哈希值存在Block Header里，只要根哈希值是正确的，就能保证底下的树不会被篡改。如果有新区块发布，新区块中包含新的交易，执行这个交易必然会使哈希表的内容发生变化，发布下一个区块的时候，还需要重新把哈希表中的内容组织成一个Merkle tree，这个代价是不是太大了。实际操作中，账户状态发生变化的只是一小部分，大多数是不变的，所以每次都重新构造一次Merkle tree，这个代价是很大的。</p> <p>比特币系统当中也是每出现一个区块都要重新构造一个Merkle tree，这为什么没有问题？比特币系统中的Merkle tree是把区块里包含的交易组织成一个Merkle tree，那区块中的交易每次发布一个新的区块又有一系列新的交易，比特币中的Merkle tree是不变（immutable）的。每次发布一个新的区块对应一个Merkle tree，然后这棵Merkle tree构建完之后是不会再改的，下次再发布一个新的区块再构建一个新的Merkle tree，那区块里有多少个交易呢？最多差不多4000个（按照1M字节，每个交易大概是250字节左右），其实是一个上限，很多区块的交易数目根本到不了4000个，有好多区块就只有几百个，甚至有可能还有更少的，所以每次发布一个区块，比特币里构建一个Merkle tree，是要把这几百个到几千个交易构成一个Merkle tree。</p> <p>如果以太坊中想要采取类似比特币中构建Merkel tree的方法，则需要把所有的以太坊账户一起构成一个Merkle tree，这个就比比特币系统中每个区块中的几百、几千个交易要高出好几个数量级，相当于每次发布一个区块要把所有的账户遍历一遍构建出一个Merkle tree，下次再有一个区块，再把所有的账户遍历一遍，再构建出一个Merkle tree。除了提供Merkle proof证明账户有多少钱之外，这个Merkle tree还有另外一个很重要的作用，就是维护各个全节点之间状态的一致性，如果没有根哈希值不去发不出来，每个节点就是在本地维护一个数据结构，那怎么知道你的数据结构的状态跟别人的数据结构的状态是不是一致呢，要各个全节点保持状态的一致才行，这也是为什么比特币中把根哈希值写在块头里的原因，就是对于当前区块中包含哪些交易，所有的全节点要有一个共识。</p> <p>综上所述，如果每个全节点在本地维护一个哈希表，然后需要构建Merkle tree的时候构建出Merkle tree来，然后根哈希值发到区块头里，这个方法是不行的。哈希表本身的效率是挺好的，插入、更改效率都很好，但是每次构建Merkle tree的代价太大了。</p></li> <li><p>不排序的Merkle tree</p> <p>能不能不要哈希表了，直接用一个Merkle tree把所有的账户都放进去，要修改账户状态的时候直接在Merkle tree里改，因为每个区块更新的只是一小部分账户，所以改的时候只是Merkle tree里的一小部分？这个方法的问题就在于Merkle tree没有提供一个高效的查找、更新的方法，比特币的Merkle tree是怎么构建的，就最底下一层是tx，然后哈希值放到上面节点里，两两结合，然后再取一个哈希往上整，他没有提供一个快速查找，更新的方法。</p> <p>还有一个问题是，如果这样构建Merkle tree，就直接把账户放到Merkle tree里，这个Merkle tree需不需要排序，之前提到过Sorted Merkle tree，如果不排序，查找速度会慢，比特币中如果证明一个交易在这个区块中是不需要排序的，如果证明一个交易不在这个区块中，是需要排序的，否则证明的代价就非常大了。如果不排序还有一个问题：叶节点是这些账户的信息，如果不规定这些账户在叶节点出现的顺序，那么这样构建出来的Merkle tree不是唯一的，比如，系统中有很多全节点，每个全节点按照自己的某个顺序排序，比如，他按照他听到某个交易的顺序构建一个Merkle tree，那么叶结点的顺序是乱的，每个叶节点的顺序都是自己决定的，最后构建出的Merkle tree是不一样的，算出的根哈希值也是不一样的。</p> <p>比特币中的节点也是不排序的，那为什么比特币就没有问题呢？因为比特币中的每个全节点收到的交易的顺序也是不一样的，理论上说构建的Merkle tree的根哈希值也是不一样的，但是比特币有一个区别，比特币中虽然也没用排序的Merkle tree，但是他那个顺序是唯一的（每个节点决定有哪些区块需要被打包在这个区块里，然后组装之后进行挖矿，新区块的Merkle tree由挖到矿的节点决定，也就是发布区块的那个节点确定的）。</p> <p>为什么以太坊不能这样做？因为如果也要这么做的话，需要把账户的状态发布到区块里，也可以说每个全节点自己决定怎么把账户组织成一个Merkle tree，算出根哈希值，挖出矿，但是想让别人知道这个顺序，需要把它发布在区块里。但是这里发布的是所有账户的状态，不是发布的区块里发布的交易，这里的交易个数跟所有账户的状态个数差了很多个数量级，而且交易是必须要发布的，这个代价必须要付出，账户状态可以维护在本地，而且大部分账户状态是不变的，一个区块里的交易只能改很少的账户，大多数账户是不变的，而且重复发布，每隔十几秒发布一个新的区块，把所有状态都打包发布一遍，下次再过十几秒再发布一遍，这个是不可行，刚才说明了不排序的Merkle tree是不行的。</p></li> <li><p>Sorted Merkle tree</p> <p>Sorted Merkle tree也会有问题，如新增一个账户时，产生一个账户的地址是随机的，他的叶节点的位置很可能是插在中间的，那后面这些树的结构都得变，插入，删除代价都很大，每次更新都需要新产生一遍Merkle tree。区块链是不可篡改的，是说添东西容易，删东西难，其实以太坊中没有显式地删除账户的操作，有的账户上就一点钱，就一两个Wei，也不能把他删掉</p></li></ul> <p>上面的方案都不行。那么以太坊中采用的方法是用一个叫MPT的结构，在此之前先学习一个简单的数据结构——trie。</p> <h3 id="mpt结构"><a href="#mpt结构" class="header-anchor">#</a> MPT结构</h3> <ul><li><p>什么是trie结构</p> <p>Trie：字典树又称前缀树，也是一种(key, value)的树，一般来说key用字符串用的比较多，如将一些单词排成一个trie的数据结构。比如将general, genesis, god, go, good排列成trie的数据结构如下图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/9e238c7f549f41f99ed5b1423744f93b.png" alt="img"></p></li></ul> <p>这几个单词都是以G开头的，然后第二个字母就开始分裂了，左边是E，右边是O，左边这前两个单词都是N和E，然后下面再分开，R和S，然后是后三个字母，右边这个分支，O这个分支，Go就已经结束了，从这个可以看到单词可能在trie的中间节点结束，然后左边是D，右边是O，左边变成了God，右边下来是Good。</p> <ul><li><p>Trie结构的特点</p> <ul><li><p>在trie当中，每个节点的分支数目取决于key值里每个元素的取值范围，这个例子当中，每个都是英文单词，而且是大写的，所以每个节点的分叉数目最多是26个，加上一个结束标志位，表示这个单词到这个地方就结束了。那在以太坊中，是什么样的呢？地址是表示成40个十六进制的数，所以分叉数目（有时也叫做Branching Factor）是17，因为是十六进制的0~f，再加上结束标志位，所以是17。</p></li> <li><p>trie的查找速率取决于key的长度，键值越长，查找需要访问的次数就越多。跟上图的例子不同，以太坊中，所有键值都是40，因为地址都是40位十六进制的数，比特币和以太坊的地址是不通用的，两个地址的格式长度都是不一样的（比特币中的地址是用公钥取哈希得到的256位的哈希值），但有一点是类似的，以太坊中的地址也是公钥经过转换得来的，其实就是公钥取哈希，然后前面的不要，只要后面这部分，就得到一个160bit的地址。</p></li> <li><p>只要两个地址不一样，最后肯定映射到树中的不同分支，所以trie是不会出现碰撞的。</p></li> <li><p>trie构造的树不受输入排序影响。前面讲Merkle tree，如果不排序的话，一个问题是账户插入到Merkle tree 的顺序不一样，得到的树的结构也不一样。相对于trie，比如这五个单词，换一个顺序插到这个树里面，得到的结果其实是一样的，只要给定的输入不变，无论输入怎么打乱重排，最后插入到trie当中，得到的树是一样的。不同的节点，不论你怎么按照顺序去插入这些账户，最后构造出来的树是一样的。</p></li> <li><p>每次发布一个区块，系统中绝大多数账户的状态是不变的，只有个别受到影响的账户才会变，所以更新操作的局部性很重要。在上面的例子中，假设要更新genesis这个key对应的value，这个图当中只画出了key，没有画value，只要访问genesis的那个分支，其他分支不用访问的，也不用遍历整棵树，更新的局部性是很好的。</p></li> <li><p>缺点：存储浪费。像图中左边分支都只有一个子节点，这种一脉单传的情况，如果能把节点进行合并，可以减小存储的开销，同时也提高了查找的效率，不用一个一个的往下找。由此引入了Patricia tree，也有人写成Patricia trie，就是经过路径压缩的前缀树，即压缩前缀树。</p></li></ul></li> <li><p>Patricia tree</p> <p>将trie进行路径压缩，结果如图所示，可以看到，G下面还是E和O进行分叉，E下面之后跟的都是EN，再往下就是E和S分叉，然后后面都和在一起了，右边都是一样的。这样压缩之后，直观上看，这个树的高度明显缩短了，访问内存的次数则会大大减少，效率会明显提高。对于Patricia tree来说，新插入一个单词，原来压缩的路径可能需要扩展开，比如这个例子当中，加入geometry，左边的分支就不能这样压缩了。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/3d2a14c5e19741859d43111600d5b1a9.png" alt="img"></p> <p>路径压缩在什么情况下效果比较好？树中插入键值的分布如果是比较稀疏的情况下，做不做路径压缩效果差距比较大，比如说，这个例子当中是用英文单词，比如说每个单词都很长，但是一共没有几个单词，举个例子，比如说有misunderstanding，decentralization（去中心化），disintermediation（非中间化）（intermediaries：中间商)。这三个单词插入到一个普通的trie里面就成了下图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/b36d19408d6f4c78b9e4740ea6e3fc76.png" alt="img"></p> <p>这样的结构效率是比较低的，用Patricia tree的结果如下图，这个树的高度明显改善。键值分布比较稀疏的时候，路径压缩效果比较好。如果应用在以太坊中，键值则为地址，地址是160位的，所以地址空间有$2^{160}$，这是一个非常非常大的数，如果设计一个计算机程序的算法，需要进行运算的次数是，那这个在我们的有生之年都不可能算出来，全世界的以太坊的账户数目加在一起也远远没有这么大，跟这个数比，是微乎其微的，所以以太坊的账户是非常非常稀疏的。为什么设计地这么稀疏，不把地址长度缩短一点，这样访问效率也快，也没必要那么稀疏了？以太坊中普通账户的创建方法跟比特币账户的创建方法是一样的，没有中央的节点，每个用户独立创建账户，在本地产生一个公私钥对，就是一个账户。为了防止两个人的账户碰撞（即产生的账户一样，这种可能性是存在的，但是实际发生碰撞的概率是非常小的），特将地址设计得足够长，分布足够稀疏。这个可能看上去有点浪费，但是这是去中心化的系统防止账户冲突的唯一办法，所以是非常稀疏的，这就是为什么在数据结构中，要用Patricia tree。</p></li></ul> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/e1496fbef1454122865ecf8a491c8468.png" alt="img"></p> <ul><li><p>MPT（Merkle Patricia tree）</p> <ul><li><p>什么是Merkle Patricia tree</p> <p>区块链与普通链表的区别：把普通指针换成了哈希指针。Merkel tree和Binary tree的区别：把普通指针换成了哈希指针。在以太坊系统中，将所有账户组织成一个Patricia tree（用路径压缩提高效率），然后把普通指针换成哈希指针，计算出根哈希值，写在Block Header里。比特币的Block Header里只有一个根哈希值，就是区块里包含的交易组成的Merkle tree组成的根哈希值，以太坊中有三个，有一个交易组成的交易树、用户状态组成状态树、和收据树，状态树由账户状态组成，他的根哈希值也是写在Block Header里。</p></li> <li><p>根哈希值的作用</p> <p>①防止篡改。根哈希值不发生变化，整个树的任何部分都没有办法被篡改。也就是说，可以使用根哈希值来验证账户的状态是否被篡改过。</p> <p>②Merkle Proof：证明账户的余额是多少。该账户所在的分支自己向上作Merkle Proof发给轻节点，轻节点可以验证该账户的余额。</p> <p>③验证一个交易是不存在的。给一个地址转账之前，验证一下全节点里有没有这个账户信息，即证明MPT中某个键值是不存在的。证明方法跟Sorted Merkle tree类似，如果存在的话，是在什么样的分支，把这个分支作为Merkle Proof发过去，从而可以证明某个账户信息是不存在的。</p></li> <li><p>以太坊中的MPT——Modified MPT</p> <p>以太坊中用到的不是原生的MPT，是Modified MPT，这里对MPT做了一些修改，这些修改并非本质的修改，如图所示，树中的根节点Root取哈希后得到的根哈希值会被写在块头里，如图左上角所示。另，图中各个节点原本存放地址的位置在这里存放的都是哈希值，具体方式参考[比特币-思考](##1.11 BTC 思考)。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/53908235f2c841c488b361ddc72e99fe.png" alt="img"></p> <p>每次发布一个新的区块的时候，这个状态树中，有一些节点的值会发生变化，这些改变不是在原地修改，而是新建一个分支，所以说原来的状态实际上是保留下来的，如图所示，以太坊中其实是一个大的MPT里面包含很多小的MPT，每个账户都有一个小的MPT。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/4cdfb51256eb412da370cdcc7579b732.png" alt="img"></p> <p>系统中每个全节点需要维护的并非一棵MPT，而是每次出现一个区块，都要新建一个MPT，只不过这些状态树中，大部分的节点是共享的，只有少部分发生变化的节点要新建分支。</p> <p>为什么要保留历史状态，不能在原地直接修改状态树？系统当中有时候会出现分叉，临时性的分叉是很普遍的，以太坊将出块时间降低到十几秒，导致临时性分叉成为常态（因为区块在网上传播时间可能也需要十几秒）。假设由有个分叉，这两个节点同时获得记账权，上面的分叉胜出，成为最长合法连，下面这个分叉的节点就要回滚（roll back）。也就是说这个节点当前的状态（接受了下面这个节点的状态）要取消，退回到之前的状态，然后沿着上面那条合法链往下推进，如图所示，红色区块所在的链就是需要回滚的。实现回滚呢，就要维护这些历史纪录。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/9948debc603b4403a2b93a3280c45522.png" alt="img"></p> <p>与比特币不太一样，在比特币系统中，交易类型比较简单，有的时候可以通过反向操作推算出前一个状态。假设存在一个转账交易，A→B（10BTC)。对账户余额的影响就是：A的账户上少了10BTC，B的账户多10BTC，假如这个状态要回滚，就把B账户减少10BTC，A账户加10BTC就行了，简单的转账交易回滚是比较容易的。以太坊中为什么不能直接回滚？因为以太坊中有智能合约，是图灵完备的，编程功能是很强的，从理论上说，可以实现很复杂的功能，跟比特币简单的脚本不太一样，所以以太坊中如果不保存前面的状态，智能合约执行完之后，想在推算出前面是什么状态，这是不可能的，所以想支持回滚，必须保存历史状态。</p></li></ul></li></ul> <h3 id="以太坊中的数据结构"><a href="#以太坊中的数据结构" class="header-anchor">#</a> 以太坊中的数据结构</h3> <ul><li><p>块头Block Header的定义</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/1f036cc3809f49498f39ae44ed105091.png" alt="img"></p> <div class="language-solidity extra-class"><pre class="language-solidity"><code><span class="token comment">// Header represents a block header in the Ethereum blockchain.</span>
type Header <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    ParentHash  common<span class="token punctuation">.</span>Hash    `json<span class="token punctuation">:</span><span class="token string">&quot;parentHash&quot;</span>        gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
    UncleHash   common<span class="token punctuation">.</span>Hash    `json<span class="token punctuation">:</span><span class="token string">&quot;sha3Uncles&quot;</span>        gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
    coinbase    common<span class="token punctuation">.</span>Address `json<span class="token punctuation">:</span><span class="token string">&quot;miner&quot;</span>             gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
    Root        common<span class="token punctuation">.</span>Hash    `json<span class="token punctuation">:</span><span class="token string">&quot;stateRoot&quot;</span>         gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
    TxHash      common<span class="token punctuation">.</span>Hash    `json<span class="token punctuation">:</span><span class="token string">&quot;transactionsRoot&quot;</span>  gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
    ReceiptHash common<span class="token punctuation">.</span>Hash    `json<span class="token punctuation">:</span><span class="token string">&quot;receiptsRoot&quot;</span>      gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
    Bloom       Bloom          `json<span class="token punctuation">:</span><span class="token string">&quot;logsBloom&quot;</span>         gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
    Difficulty  <span class="token operator">*</span>big<span class="token punctuation">.</span>Int       `json<span class="token punctuation">:</span><span class="token string">&quot;difficulty&quot;</span>        gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
    Number      <span class="token operator">*</span>big<span class="token punctuation">.</span>Int       `json<span class="token punctuation">:</span><span class="token string">&quot;number&quot;</span>            gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
    GasLimit    <span class="token builtin">uint64</span>         `json<span class="token punctuation">:</span><span class="token string">&quot;gasLimit&quot;</span>          gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
    Gasused     <span class="token builtin">uint64</span>         `json<span class="token punctuation">:</span><span class="token string">&quot;gasused&quot;</span>           gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
    Time        <span class="token operator">*</span>big<span class="token punctuation">.</span>Int       `json<span class="token punctuation">:</span><span class="token string">&quot;timestamp&quot;</span>         gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
    Extra       <span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token builtin">byte</span>        `json<span class="token punctuation">:</span><span class="token string">&quot;extraData&quot;</span>         gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
    MixDigest   common<span class="token punctuation">.</span>Hash    `json<span class="token punctuation">:</span><span class="token string">&quot;mixHash&quot;</span>           gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
    Nonce       BlockNonce     `json<span class="token punctuation">:</span><span class="token string">&quot;nonce&quot;</span>             gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span>`
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>区块Block的定义</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/74b44656d5924de4a81f383c2306e44b.png" alt="img"></p> <div class="language-solidity extra-class"><pre class="language-solidity"><code><span class="token comment">// Block represents an entire block in the Ethereum blockchain.</span>
type Block <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    header       <span class="token operator">*</span>Header
    uncles       <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Header
    transactions Transactions
    
    <span class="token comment">//caches</span>
    hash atomic<span class="token punctuation">.</span>value
    size atomic<span class="token punctuation">.</span>value
 
    <span class="token comment">//Td is used by package core to store the total difficulty</span>
    <span class="token comment">//of the chain up to and including the block.</span>
    td <span class="token operator">*</span>big<span class="token punctuation">.</span>Int
 
    <span class="token comment">//These fields are used by package eth to trackl</span>
    <span class="token comment">//inter-peer block relay.</span>
    ReceivedAt   time<span class="token punctuation">.</span>Time
    ReceivedFrom <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>External block</p> <p>一个区块真正在网上发布的时候就是发布这些信息，如图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/22cd395507394f09bb775a9b7130f0f9.png" alt="img"></p> <div class="language-solidity extra-class"><pre class="language-solidity"><code>type extbllock <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    header       <span class="token operator">*</span>Header
    Txs          <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Transactions
    uncles       <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Header
<span class="token punctuation">}</span>
</code></pre></div><p>状态树中保存的是（key, value)，key就是地址，目前主要讲的是键值，这个地址的管理方式。value，即账户的状态，是如何存储在状态树当中的？这需要经过一个序列化（RLP: Recursive  Length Prefix）的过程，然后再存储。RLP是一种序列化方法，其特点是简单、极简主义，越简单越好。Protocal buffer：简称Protobuf，是个很有名的做序列化的库。跟这些库相比，RLP的理念就是越简单越好，只支持一种类型，nested array bytes（字节数组），即一个一个字节组成的数组（可以嵌套）。以太坊里的所有的其他类型，如整数和哈希表等，最后都要变成nested array bytes。所以，实现RLP要比实现Protocal buffer简单很多，因为难的东西都不做，都交给应用层做。</p></li></ul> <h2 id="eth-交易树和收据树"><a href="#eth-交易树和收据树" class="header-anchor">#</a> ETH 交易树和收据树</h2> <h3 id="以太坊中的三种树"><a href="#以太坊中的三种树" class="header-anchor">#</a> 以太坊中的三种树</h3> <p>​       在以太坊中，存在三种基于树的数据结构——状态树、交易树和收据树。所有的交易会组成一棵Merkle tree，叫交易树，交易树类似于比特币系统中的Merkle tree。此外，以太坊中还增加了收据树，每个交易执行完之后会形成一个记录这个其相关信息的收据，交易树和收据树上面的节点是一 一对应的。增加这个收据树的目的是便于快速查询执行的结果（主要因为以太坊的智能合约执行过程比较复杂）。</p> <div class="language- extra-class"><pre><code>    从数据结构上来看，交易树和收据树都是MPT，与比特币系统不同，比特币系统中的交易树就是由区块里的所有交易组织成的一个普通的Merkle tree，MPT也是Merkle Patricia tree，跟比特币系统中有所不同。为了方便，以太坊中的三棵树都用同样的数据结构，这样代码比较统一，便于管理，当然用MPT的一个好处是支持查找操作，可以通过键值从顶向下沿着这颗树查找。在状态树中，查找的键值就是这个账户的地址，对于交易树和收据树来说，查找的键值就是这个交易在发布的区块里的序号，就他的排序，这个交易的排列顺序是由发布区块的那个节点决定的。
</code></pre></div><h3 id="状态树、交易树和收据树的区别"><a href="#状态树、交易树和收据树的区别" class="header-anchor">#</a> 状态树、交易树和收据树的区别</h3> <ul><li><p>交易树和收据树都是只将当前发布的区块里的交易组织起来，状态树需要把系统中所有账户的状态都要包含进去，不管这些账户跟当前区块的交易有没有什么关系。</p></li> <li><p>从数据结构上来说，多个区块的状态树是共享节点的（新发布一个区块的时候，只有该区块中改变了状态的节点需要新建一个分支，其他节点都是沿用原来状态树上的节点），相比之下，每个区块的交易树和收据树都是独立的，是不会共享节点的（一个区块和另一个区块发布的交易本身也认为是独立的）。</p></li></ul> <h3 id="_3-交易树和收据树的用途"><a href="#_3-交易树和收据树的用途" class="header-anchor">#</a> （3）交易树和收据树的用途</h3> <ul><li><p>交易树和收据树的用途</p> <p>提供Merkle Proof。比特币系统中，交易树可以证明某个交易被打包到某个区块里面，即向轻节点提供这样的Merkle Proof。收据树也是类似的，可以提供Merkle Proof来证明某个交易的结果，除此之外，以太坊还支持一些更加复杂的查询操作，比如说，想查询过去十天当中，所有与某个智能合约有关的交易（一种方法是把过去十天产生的所有区块都扫描一遍，看看其中有哪些交易是和智能合约相关的，但是这种方法有几个缺点：①复杂度较高，是线性的；②得有足够得存储来保存整个集合的元素；③实际上，轻节点没有交易列表，只有一个块头的信息，所以也没有办法通过扫描所有交易列表的方法来找到符合这个查询条件的交易），与之类似的一些查询，找到过去十天当中符合某种类型的所有事件（如，所有的众筹事件或者所有的发行新币的事件），这些都需要一个比较高效的方法。</p></li> <li><p>如何实现复杂的查询操作</p> <p>以太坊中引入了Bloom Filter，这种数据结构可以支持比较高效的查找某个元素是不是在一个比较大的集合里，比如说有一个集合，里面有很多元素，现在想知道某个指定的元素是不是在这个集合里。Bloom Filter给这个包含很多元素的集合计算出一个很紧凑的摘要（如一个128位的向量）。如，有一个集合(a,b,c)，要计算出digest，其下方是一个初始全为零的向量，存在一个哈希函数H，将元素中每个元素取哈希后映射到向量表中，将这个位置的元素从0变成1，如下图所示。集合中所有元素都这样处理完，得到的向量就是原集合的一个摘要，这个摘要比原集合小很多。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/1e90c0faa0c249b39c4dc95391165ef3.png" alt="img"></p> <p>摘要的用处：假设有一个元素d，想知道这个d是否在某集合里，但集合本身不一定能保存下来，可以用这个哈希函数H对d取哈希值，比如说，取完哈希值之后，映射到向量中某个是0的位置，则说明该元素一定不在该集合里：<img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/06bbd3265c0545078a7650f1ccbd7426-1678440381089-5.png" alt="img"></p> <p>若取完哈希值之后，映射到向量中某个是1的位置，则不能说明该元素在该集合里，有可能确实是集合中的元素，d=a，也有可能d不在该集合里，但出现了哈希碰撞，恰好映射到跟集合某个元素一样的位置，所以使用Bloom Filter要注意，有可能会出现false positive，但是不会出现false negative，就是可能出现误报，但是不会出现漏报。即若元素属于集合，则判断出来一定为元素属于集合；元素不属于集合，也可能判断出来元素属于集合。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/9bf3fea3eaf1414fa33c2786b32194fc.png" alt="img"></p> <p>Bloom Filter有各种各样的变种，为解决这样的哈希碰撞，有时候会用一组哈希函数而不是单个哈希函数，将某个带证明元素分别通过每个哈希函数映射到向量中的一个位置。一般来说，不会所有的哈希函数都出现哈希碰撞。Bloom Filter的局限性是不支持删除操作。比如把a删掉了，对应的向量1要不要改，如果改成0的话，集合中可能有另外一个元素也映射到这个位置（哈希碰撞是有可能的），所以简单的Bloom Filter是不支持删除操作的。若要支持删除操作，则需要将向量中的值改成一个计数器，记录该位置有多少元素映射过来，而且还需要考虑到计数器会不会溢出。这样数据结构就复杂得多了，和当初设计Bloom Filter的初衷相违背，所以一般来说，Bloom Filter是不支持删除操作的。</p></li> <li><p>以太坊中Bloom Filter的用途</p> <p>每个交易执行完之后会形成一个包含Bloom Filter的收据，Bloom Filter用于记录交易的类型、地址等信息。发布的区块的块头里也有一个总的Bloom Filter，是这个区块里所有交易的一个Bloom Filter的并集。比如说要查找过去十天发生的跟智能合约相关的交易，可以找一些有哪些区块的块头的bloom filter有要的交易类型，如果没有，这个区块就不是我们想要的，如果有，再去查找区块里面包含的交易所对应的收据树里面的那些Bloom Filter（就每个收据的bloom filter）看看哪个有，也可能都没有，因为有可能是false positive。如果是有的话，再找到相对应的交易直接进行一下确认，好处是通过Bloom Filter的结构能够快速过滤掉大量无关的区块，就很多区块，一看块头的Bloom Filter就知道肯定没有我们要的交易，然后剩下的一些少数的候选区块，再仔细查看。比如轻节点，只有块头信息，根据块头就已经能够过滤掉很多区块了，剩下有可能是想要的区块，再问全节点要进一步的信息即可。</p></li></ul> <h3 id="以太坊的运行过程"><a href="#以太坊的运行过程" class="header-anchor">#</a> 以太坊的运行过程</h3> <p>这三棵树的根哈希值都包括在块头里面，以太坊的运行过程可以看作一个交易驱动的状态机（Transaction-driven State Machine），这个状态机的状态是所有账户的状态，即状态树中包含的那些内容，交易是指每次发布区块里包含的交易，通过执行这些交易会驱动系统从当前状态转移到下一个状态。比特币系统也可以认为是一个交易驱动的状态机，比特币中的状态是UTXO（没有被花掉的那些输出），每次新发布一个区块，会从UTXO里用掉一些输出，又会增加一些新的输出，发布的区块会驱动系统从当前状态转移到下一个状态。而且这两个状态机有一个共同的特点，就是状态转移都得是确定的，对一个给定的当前状态，一组给定的区块中包含的交易，能确定性地转移到下一个状态。因为所有的全节点，所有地矿工，都要执行同样的状态转移，所以状态转移必须是确定性的。</p> <h3 id="思考"><a href="#思考" class="header-anchor">#</a> 思考</h3> <ul><li><p>问题1：某人在以太坊发布一个交易，有人收到这个交易，转账交易A-&gt;B，有没有可能这个收款人的地址从来没听说过？</p> <p>以太坊系统和比特币系统类似，创建账户时不需要通知其他人的，只有这个账户第一次收到钱的时候，其他的节点才会知道这个账户的存在，这个时候因为新插入了一个账户，所以要在状态树中新插入的一个节点。</p></li> <li><p>问题2：状态树和交易树、收据树的区别是，状态树要包含系统中所有账户的状态（无论这些账户是否参与了当前区块的交易），那能否将状态树的设计修改成每个区块的状态树也只包含这个区块中的交易相关的那些账户的状态，与交易树和收据树一致，而且可以大幅度削减每个区块所对应的状态树的大小（因为大部分的账户状态是不会变的）？</p> <p>如果这样设计，每个区块没有一颗完整的状态树（只有当前区块中包含的交易涉及到的账户的状态），这么设计会使，如果要想查找某个账户的状态就会变得不方便。假设存在一个转账交易A→B(10ETH)，要检查A账户里是不是真的有10ETH，但是当前区块和最近一个区块对应的那个状态树可能没有这个账户，那么需要往前一直找，直到找到最近的一个包含A账户的区块，才能知道A的账户余额是多少。如果A有较长的一段时间没有发生交易，可能要从后往前，扫描很多个区块，才能找到最近一次的账户状态。还有一个更大的问题，A给B转账，要知道A账户的状态，才能知道A是不是有足够的钱转给B，也要知道B账户的状态，余额是多少（因为要往B账户余额里加10ETH），但B账户有可能是个新建的账户，这时候需要从当前区块一直扫描到创世纪块，发现这个账户没有，才知道原来是个新建的账户。</p></li></ul> <h3 id="代码中的具体体现"><a href="#代码中的具体体现" class="header-anchor">#</a> 代码中的具体体现</h3> <ul><li><p>交易树和收据树的创建过程</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/252c36bab46e4d9e83fcf458f515b2f5.png" alt="img"></p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">NewBlock</span><span class="token punctuation">(</span>header <span class="token operator">*</span>Header<span class="token punctuation">,</span>txs <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Transaction<span class="token punctuation">,</span>
                uncles <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Header<span class="token punctuation">,</span>receipts <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Receipt<span class="token punctuation">)</span><span class="token operator">*</span>Block <span class="token punctuation">{</span>
    b <span class="token operator">:=</span> <span class="token operator">&amp;</span>Block<span class="token punctuation">{</span>header<span class="token punctuation">:</span> <span class="token function">CopyHeader</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">,</span>td<span class="token punctuation">:</span> <span class="token function">new</span><span class="token punctuation">(</span>big<span class="token punctuation">.</span>Int<span class="token punctuation">)</span><span class="token punctuation">}</span>
 
    <span class="token comment">//TODO: panic if len(txs）!= len(receipts)</span>
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>txs<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token punctuation">{</span>
        b<span class="token punctuation">.</span>header<span class="token punctuation">.</span>TxHash <span class="token operator">=</span> EmptyRootHash
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        b<span class="token punctuation">.</span>header<span class="token punctuation">.</span>TxHash <span class="token operator">=</span> <span class="token function">DeriveSha</span><span class="token punctuation">(</span><span class="token function">Transactions</span><span class="token punctuation">(</span>txs<span class="token punctuation">)</span><span class="token punctuation">)</span>
        b<span class="token punctuation">.</span>transactions <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>Transactions<span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>txs<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">copy</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>transactions<span class="token punctuation">,</span>txs<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>receipts<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token number">0</span> <span class="token punctuation">{</span>
        b<span class="token punctuation">.</span>header<span class="token punctuation">.</span>ReceiptHash <span class="token operator">=</span> EmptyRootHash
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        b<span class="token punctuation">.</span>header<span class="token punctuation">.</span>ReceiptHash <span class="token operator">=</span> <span class="token function">DeriveSha</span><span class="token punctuation">(</span><span class="token function">Receipts</span><span class="token punctuation">(</span>receipts<span class="token punctuation">)</span><span class="token punctuation">)</span>
        b<span class="token punctuation">.</span>header<span class="token punctuation">.</span>Bloom <span class="token operator">=</span> <span class="token function">CreateBloom</span><span class="token punctuation">(</span>receipts<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>uncles<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token number">0</span> <span class="token punctuation">{</span>
        b<span class="token punctuation">.</span>header<span class="token punctuation">.</span>UncleHash <span class="token operator">=</span> EmptyUncleHash
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        b<span class="token punctuation">.</span>header<span class="token punctuation">.</span>UncleHash <span class="token operator">=</span> <span class="token function">CalcUncleHash</span><span class="token punctuation">(</span>uncles<span class="token punctuation">)</span>
        b<span class="token punctuation">.</span>uncles <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Header<span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>uncles<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> uncles <span class="token punctuation">{</span>
            b<span class="token punctuation">.</span>uncles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token function">CopyHeader</span><span class="token punctuation">(</span>uncles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> b
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>DeriveSha函数</p> <p>NewBlock函数创建交易树和收据树的时候用到的都是这个函数，这里创建的数据结构是一棵<a href="https://so.csdn.net/so/search?q=Trie&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">Trie<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，而Trie的数据结构是MPT。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">DeriveSha</span><span class="token punctuation">(</span>list DerivableList<span class="token punctuation">)</span> common<span class="token punctuation">.</span>Hash <span class="token punctuation">{</span>
    keybuf <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span>
    trie <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>trie<span class="token punctuation">.</span>Trie<span class="token punctuation">)</span><span class="token comment">//创建的数据结构是一个Trie</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        keybuf<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        rlp<span class="token punctuation">.</span><span class="token function">Encode</span><span class="token punctuation">(</span>keybuf<span class="token punctuation">,</span> <span class="token function">uint</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
        trie<span class="token punctuation">.</span><span class="token function">Update</span><span class="token punctuation">(</span>keybuf<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>list<span class="token punctuation">.</span><span class="token function">GetRlp</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> trie<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">//Trie is a Merkle Patricia Trie.Trie是一棵MPT</span>
<span class="token comment">// The zero value is an empty trie with no database.</span>
<span class="token comment">// Use New to create a trie that sits on top of a database.l /</span>
<span class="token comment">// Trie is not safe for concurrent use.</span>
<span class="token keyword">type</span> Trie <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    db           <span class="token operator">*</span>Database
    root         node
    originalRoot common<span class="token punctuation">.</span> Hash
 
    <span class="token comment">// Cache generation values.</span>
    <span class="token comment">// cachegen increases by one with each commit operation.</span>
    <span class="token comment">// new nodes are tagged with the current generation and unloaded</span>
    <span class="token comment">// when their generation is older than than cachegen-cachelimit.</span>
    cachegen<span class="token punctuation">,</span>cachelimit <span class="token builtin">uint16</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>Receipt的数据结构</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/7d5706daf1d8468fb6c3eaa1bb8f2873.png" alt="img"></p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">// Receipt represents the results of a transaction.</span>
<span class="token keyword">type</span> Receipt <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token comment">// Consensus fields</span>
    PostState            <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token string">`json:&quot;root&quot;`</span>
    Status               <span class="token builtin">uint64</span> <span class="token string">`json:&quot;status&quot;
    CumulativeGasUsed    uint64 `</span>json<span class="token punctuation">:</span><span class="token string">&quot;cumulativeGasUsed&quot;</span> gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span><span class="token string">`
    Bloom                Bloom  `</span>json<span class="token punctuation">:</span><span class="token string">&quot;logsBloom&quot;</span>         gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span><span class="token string">`
    Logs                 []*Log `</span>json<span class="token punctuation">:</span><span class="token string">&quot;logs&quot;</span>              gencodec<span class="token punctuation">:</span><span class="token string">&quot;required&quot;</span><span class="token string">`
 
    //Implementation fields (don 't reorder !)
    TxHash          common.Hash    `</span>json<span class="token punctuation">:</span><span class="token string">&quot;transactionHash&quot;</span> gencodec<span class="token punctuation">:</span> <span class="token string">&quot;required&quot;</span>
    ContractAddress common<span class="token punctuation">.</span>Address <span class="token string">`json:&quot;contractAddress&quot;
    GasUsed         uint64         `</span>json<span class="token punctuation">:</span> <span class="token string">&quot;gasUsed&quot;</span>        gencodec <span class="token punctuation">:</span> <span class="token string">&quot;required&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>Bloom Filter</p> <p>之前学习过的区块块头的数据结构，里面的Bloom域就是整个区块的bloom filter，这个是由刚才看到的每个收据的Bloom Filter合在一起得到的。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/102f121ecd644aaeb3451ea65c85f05a.png" alt="img"></p> <p>NewBlock函数中的红框里的代码就是创建块头里的bloom filter，通过调用CreateBloom这个函数。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/585bc069f52447b4a60ee72894d99a1e.png" alt="img"></p> <p>CreateBloom、LogsBloom、bloom哈希函数的代码实现：</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/2de82497727743a3826fbda2de40e724.png" alt="img"></p> <p>查询某个Bloom Filter里面是否包含了某感兴趣的topic就用到图6-6所示的BloomLookup函数。查一下bin的bloom filter里有没有包含要找的第二个参数topic，首先用刚才讲的bloom9函数把topic转化成一个bytesBacked，然后把他跟Bloom Filter取and操作，看看得到的结果是不是和bytesBacked相等。注意，Bloom Filter里面可能包含除了我们要查找的topic之外其他的topic，所以要做一个and，然后再跟他自身比较，相当于判断一下我们要查找的这个topic在Bloom Filter中对应的位置是不是都是1。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/9496c543ba09430aa5d0d4d7d0190df4.png" alt="img"></p></li></ul> <h2 id="eth-ghost协议"><a href="#eth-ghost协议" class="header-anchor">#</a> ETH GHOST协议</h2> <h3 id="以太坊的出块时间及可能带来的问题"><a href="#以太坊的出块时间及可能带来的问题" class="header-anchor">#</a> 以太坊的出块时间及可能带来的问题</h3> <ul><li><p>以太坊的出块时间</p> <p>以太坊将出块时间降到了十几秒，提高了系统的吞吐量（Throughput）、降低了反应时间。与比特币系统出块时间的10分钟相比，以太坊的出块速度相当于提高到40倍，这样大幅度降低出块时间后也带来一些新的问题。比特币和以太坊都是运行在应用层的共识协议，底层是一个P2P的Overlay Network，Overlay Network本身的传输时间比较长（其拓扑协议做flooding的时候没有考虑实际的拓扑结构）。带来一个问题：发布区块的时候，该区块在网络上传到其他节点可能需要十几秒，那么就有较大可能会有两个节点（甚至多个），同时获得记账权，从而造成临时性分叉。</p></li> <li><p>以太坊与比特币系统的平均出块时间对比</p> <p>对于比特币系统来说，平均出块时间是600秒，足够让新发布的区块传播到网上的其他节点，但由于挖矿是个概率的过程，仍有两个矿工同时获得记账权、同时发布区块的可能，会带来临时性的分叉。在以太坊中，这种临时性的分叉会变成常态，而且分叉的数目也会变得更多（十几秒的出块时间很有可能别的节点没有来得及收到发布的区块，还沿着原来的区块链往下挖，可能等到收到发布的区块的时候，他自己已经挖到了区块），这对于共识协议来说，是一个挑战。</p></li> <li><p>带来的问题</p> <p>比特币系统中，只有在最长合法链上的那些区块，所包含的出块奖励才是真正有用的，其他的一些分叉的链上的出块奖励其实是作废的。比如图中区块链，分了三个叉，差不多是同一个时间取得了记账权，最后有一个会胜出成为最长合法链，假定中间区块胜出，那么上面和下面的这个区块叫做Orphan Block或Stale Block，挖到这类区块的矿工在里面有一个铸币交易，能够得到一定数量的比特币，但这个实际上是没有用的，因为不在最长合法链上，所以得到的出块奖励最后等于作废了。对于比特币来说，这种临时性的分叉不是很多，所以这么规定可以接受。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/cc6afa22531345cbbf6129b3ab445d0f.png" alt="img"></p> <p>对于以太坊来说，如果也将分叉区块的出块奖励作废的话，则意味着这个矿工挖到的区块有很大概率是白挖，对于个体矿工特别明显。按照常理，矿工的收益应该与算力成正比，矿池的收益也应当与矿池的总算力成正比。但大型矿池会出现Mining Centralization（挖矿集中化），即大型矿池所在的分叉更有可能成为最长合法链，这促使别的矿工沿着最长合法链继续挖（因为如果别的链去挖，很有可能白挖）。这样会使大型矿池出现恶性循环，越是大型矿池得到的收益越大，Mining Centralization更严重，有时候叫Centralization Bias，即中心化带来的不成比例的优势。如果以太坊按照比特币的共识机制就会有一定的问题。</p></li></ul> <h3 id="ghost协议"><a href="#ghost协议" class="header-anchor">#</a> GHOST协议</h3> <p>为解决以太坊如果按照比特币的共识机制产生的问题，采用一个<strong>基于GHOST协议的共识机制</strong>，这个协议并非以太坊发明的，以太坊只是对该协议做了一些修改。</p> <ul><li><p>GHOST协议的核心思想</p> <p>挖到矿的矿工发布一个区块，即便这个区块最后作废了，也会给予一些奖励，这个时候也能得到一些出块奖励，将作废的区块（上图中的Orphan Block或Stale Block）称为Uncle Block。相对于最长合法链的当前区块来说，是他的叔父区块，最长合法链的下一个区块在发布的时候可以把叔父区块包含进来，如图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/f06f9d9b754549209f02fd2ea10ad65a.png" alt="img"></p> <p>该协议的核心思想是：<strong>给予挖到矿但是没有成为最长合法链的那些矿工一种安慰</strong>。虽然挖的区块没有成为最长合法链上的区块，但仍可以得到大部分的区块奖励。这样有利于鼓励系统中出现分叉后及时合并，相当于最长合法链上面的区块将另外两个分叉链给招安过来，这是GHOST协议最初的版本。</p></li> <li><p>GHOST协议的缺陷</p> <ul><li><p>Uncle Block的个数不能超过两个</p> <p>Uncle Block只能包含两个，如果出现第三个Uncle Block，如下图所示，设计GHOST的目的是给Uncle Block一点好处，把它们合并过来，但是只能招安两个，如果出现第三个Uncle Block就没办法了。其实，只能包含两个Uncle Block也是有道理的，因为叔父区块得到八分之七的出块奖励是很高的，要是不限制的话，那么以太币就太不值钱了。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/de8fd91bc6e84d47ab3066ce2da7a933.png" alt="img"></p></li> <li><p>区块传播存在延迟</p> <p>区块D把区块A作为叔父区块的前提是：在挖这个区块D的时候已经知道区块A这个叔父区块的存在了，如果已经发布了D这个区块，然后才知道叔父区块，这时候已经来不及了，叔父区块就变成什么好处都没有了。</p></li> <li><p>受矿工主观影响</p> <p>如果这个矿工比较自私的话，出于商业目的，有可能故意不包含叔父区块，就是挖的时候知道这个叔父区块，但是就是不包含，这样的话，对叔父区块来说，7/8的出块奖励是得不到的，对于他自己来说，1/32的出块奖励是得不到了，好像是损人不利己，但要从商业竞争的角度讲，这么做对这个矿工的损失是比较小的，对挖出叔父区块的矿工的损失是比较大的。</p></li></ul></li> <li><p>改进后的GHOST协议</p> <p>改进后的GHOST协议如图所示。这么规定解决了矿池出于竞争关系故意不把某个叔父区块包含进去的问题。比如区块D故意不包含区块A，但是区块E仍然可以包含区块A。甚至有可能出现一个情况：挖到区块A的矿工发现自己不在最长合法链上，就沿着区块D挖出了区块E，然后就可以把自己的区块A包含进去。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/79d0524e478943dbbc1ff54a8b4a387e.png" alt="img"></p> <p>这样的话，也解决了出现第三个叔父区块的问题。改进的GHOST协议的本质就是为了改进最初版本的GHOST协议存在的一些问题，所以把叔父的定义扩展了，不一定是当代叔父，可能是隔着几代的叔父。以太坊规定，叔父区块可以得到7/8的出块奖励。如果往前推一代，叔父区块得到6/8的出块奖励。以此类推，只有这六个是叔父区块，再往前就不是叔父区块了，如图2-4所示。叔父区块的定义是必须跟当前区块在7代以内有共同的祖先才行，超过七代就不认了，换句话说，合法的叔父只有6个辈分。
<img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/addee6587fa145bbabbcc69589d11128.png" alt="img"></p></li> <li><p>为什么设定合法的叔父必须在当前区块在七代以内且有共同的祖先？</p> <ul><li><p>如果你不限制叔父的辈分，那么实现起来，全节点则需要维护非常多的状态（可能要记着隔着100代以前有哪些叔父区块），新发布的区块包含的叔父区块，其他节点同样也需要验证；</p></li> <li><p>设计最多隔着7代，并且这7代以内，出块奖励是逐渐递减的，有利于鼓励出现分叉之后，尽早合并，一出现分叉就马上合并的时候能得到的出块奖励是最多的，如果隔好几代之后，出块奖励就越来越少了，隔得代数太多了就得不到任何出块奖励了。</p></li></ul> <p>叔父区块的奖励叫做Uncle Reward，当前区块包含一个叔父区块，就会得到1/32的出块奖励，不论包含的是哪一个辈分的叔父。</p></li> <li><p>改进后的GHOST协议无法解决的问题
设计这个协议主要是为了解决系统中出现的临时性分叉，包括比特币、以太坊，规定最长合法链的原则的目的是防止篡改，其实也是为了解决临时性分叉。最长合法链提供一个出现临时性分叉（State Fork）之后进行合并的一种机制。如果这个分叉是别的原因造成的，比如由于对运行的区块链协议有不同的意见，那么这种方法是解决不了的，也就是说，改进后的GHOST协议仍然无法解决硬分叉。</p> <p>例如，学习比特币脚本的时候，学过的CHECKMULTISIG（用来检查多重签名的合法性），这个过程中有一个bug，检查的时候会从堆栈里多弹出一个元素，那如果正常操作的话，检查是通不过的，得先往里面压一个没用的多余的元素，就为了抵消这个Bug。这里不将这个BUG改掉就是因为：改完之后版本不一样了。比特币系统跟中心化的系统不一样（中心化的系统发布一个新版本很容易），去中心化系统如果修改的话，会出现硬分叉。图2-4的那两条链如果不是因为对当前状态有意见分歧，而是互相认为对方是非法的，认为对方的区块是包含非法交易的，那么用这种方法是合并不了的。如果有矿工将这样的区块包含进来，其他矿工会认为这条链是非法的，包含进来还是不会沿着这条链继续挖，还是沿着别的分叉链去挖，因为：即使主链最长，但是包含非法交易。</p></li></ul> <h3 id="以太坊中的奖励"><a href="#以太坊中的奖励" class="header-anchor">#</a> 以太坊中的奖励</h3> <p>区块链和以太坊发布一个区块能得到的奖励如下图所示，实际上得到的是两部分奖励，叔父区块得到八分之七的奖励只限于Block Reward，即7/8×3ETH。叔父区块是得不到汽油费的，但汽油费所占的比例是非常小的，大部分是出块奖励，跟比特币的情况是类似的。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/2a31ee763e2e4d0fb8cdd160b0d63aa7.png" alt="img"></p> <p>以太坊中没有规定定期要把出块奖励减半，比特币那么规定是为了人为制造稀缺性，以太坊中五个以太币降为三个以太币，不是为了认为制造稀缺性，实际上跟挖矿难度调整有关，2017年，挖矿难度炸弹被回调了300万个区块，导致挖矿难度大幅度下降，为了维护公平性，也是为了使以太币的供给量不要出现剧烈变化，所以降到了三个以太币，这是一次性的，并没有说以后会不断地下调。</p> <p>比特币一般当作数字黄金，是用来储值的；以太币被比喻成石油，它是用来花的，用来消耗，然后可以执行智能合约的。这个比喻不是完全的恰当，因为石油花完之后就没了，而以太坊中执行智能合约要消耗的gas，只是从一个账户转移到另外一个账户，发布智能合约的时候，要付出gas费，执行这个智能合约的矿工可以得到这个gas费，所以这个比喻也不完全恰当。</p> <h3 id="思考-2"><a href="#思考-2" class="header-anchor">#</a> 思考</h3> <ul><li><p>把叔父区块包含进来的时候，叔父区块的交易要不要执行？以太坊是一个交易驱动的状态机，比特币也一样，所以在最长合法链上每次发布一个新的区块都会使当前状态转移到下一个状态，现在引入了叔父区块，要不要执行叔父区块的交易呢？</p> <p>不应该执行，最长合法链上的父区块和他的叔父区块包含的交易可能是冲突的，如果它们包含不同的交易，不同交易有可能不能都执行。对于比特币系统，对于有冲突的交易，比特币要做Double Spending Attack，要检测是不是双花攻击。在以太坊中，双花攻击花两次减两次，但是有可能一个交易花了之后，另一个交易就没法花了。所以叔父区块的交易，可能有些交易就变成了非法交易，叔父区块本身不一定是非法的，但执行完父区块的交易，再去执行叔父区块的交易可能就变成非法的。</p> <p>以太坊中只执行在最长合法链上的交易，叔父区块这些交易，当前区块是不执行的。而且根本就不检查叔父区块交易的合法性，只检查叔父区块是不是一个合法发布的区块，即这个区块是不是符合挖矿难度，也就是有没有获得记账权。</p></li> <li><p>叔父区块能不能广义化？</p> <p>叔父区块都是分叉之后第一个区块。如果分叉之后后面还跟着一串，如图4-1所示，这些不能被认为是叔父区块。假定，将这些区块认为是叔父区块，会造成一个后果：分叉攻击的代价过低。正常意义上的分叉攻击需要使分叉链长度大于原来最长合法链长度才算成功，否则这些用来分叉攻击的区块会作废，原本的出块奖励也没有了。如果将分叉链上的区块认为使叔父区块的话，分叉攻击不成还能作为叔父区块获得一些奖励。所以以太坊中规定，只有分叉后的第一个区块可以得到Uncle Reward，后面的都不行。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/657d313bb8c6488f9d81414879834b78.png" alt="img"></p></li></ul> <h3 id="以太坊中的真实情况"><a href="#以太坊中的真实情况" class="header-anchor">#</a> 以太坊中的真实情况</h3> <p>Etherscan.io可以实时查看以太坊的当前状态，右边这个曲线显示的是过去两周的交易历史，下面还包含最新挖出的区块和最新的交易，如下图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/9568c7694b164e42b09d78886ece4412.png" alt="img"></p> <p>下图所示为叔父区块的几种情况，这里的每一行对应一个叔父区块，第一列的Block Height就是区块的序号，也就是Block Number，与表中不同辈分的叔父得到的Uncle Reward的数目相对应。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/381d79ff00d242c28ff5b8ad06c281c1.png" alt="img">
下图是两个区块的具体例子，左边这个区块包含了一个叔父区块，倒数第二行uncle reward是2.25，应该是距离为2的叔父。这个区块得到的奖励，在倒数第三行，有三个部分组成，即3ETH出块奖励、汽油费和包含叔父区块得到的三十二分之一的出块奖励。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/4583fba0b17348888e818b8d9d5003f1.png" alt="img"></p> <h2 id="eth-挖矿算法"><a href="#eth-挖矿算法" class="header-anchor">#</a> ETH 挖矿算法</h2> <h3 id="工作量证明-pow"><a href="#工作量证明-pow" class="header-anchor">#</a> 工作量证明（POW）</h3> <ul><li><p>比特币系统的工作量证明</p> <p>对于基于工作量证明的系统来说，Mining是保障区块链安全的重要手段（Block chain is secured by mining），比特币里面的Mining算法总的来说是比较成功的，经受了时间检验，到目前为止，没有人发现有什么大的漏洞。</p> <p>Bounty（赏金），Bug Bounty：有的公司悬赏来找软件中的漏洞，如果能找到软件中的安全漏洞就可以得到一笔赏金。比特币的Mining算法是一个天然的Bug Bounty，如果你能找到里面的漏洞，或者是某一个Mining的捷径就能取得很大的利益。但是到目前为止还没有人发现有什么捷径可走，所以比特币的Mining算法总的来说是比较成功的。</p></li> <li><p>比特币系统Mining算法的问题</p> <p>比特币的Mining算法也有一些值得改进得地方，其中有一个饱受争议得问题就是Mining设备得专业化，有普通的计算机挖不倒矿，只能用专门的设备，专用的ASIC芯片来Mining，那么很多人认为这种做法与去中心化的理念是背道而驰的，也跟比特币的设计初衷相违背。中本聪最早的一篇论文，提出One CPU，one vote，理想状况下，应该让普通老百姓也能参与Mining过程，这样也更安全，因为算力分散之后，有恶意的攻击者想要聚集到51%的算力发动攻击，难度就会大得多。所以比特币之后出现的加密货币包括以太坊设计Mining Puzzle的时候，就想要做到ASIC Resistance。</p></li> <li><p>如何设计出对ASIC芯片不友好的Mining Puzzle</p> <p>一个常用的做法就是增加Mining Puzzle对内存访问的需求（memory hard mining puzzle）。ASIC芯片相对于普通计算机而言，主要优势是算力强，但是在内存访问的性能上没有那么大的优势。同样的价格买一个ASIC矿机和买一个普通的计算机，这个ASIC矿机的计算能力是普通计算机的几千倍，但是内存访问方面的性能差距远没有这么大，所以能设计出一个对内存要求很高的Puzzle，就能起到遏制ASIC芯片的作用。</p></li> <li><p>LiteCoin</p> <p>LiteCoin（莱特币），曾经是市值仅次于比特币的第二大加密货币，其Puzzle是基于Scrypt（一个对内存要求很高的哈希函数，以前用于计算机安全领域，跟密码相关）。其具体设计思想是，开一个很大的数组，然后按照顺序填充一些伪随机数，比如说有一个种子节点，seed的值通过一些运算，算出一个数来，填在第一个位置，然后后面每个位置都是前一个位置的值取哈希得到的，如图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/6caee96211544af081ae81e71a45073a.png" alt="img"></p> <p>伪随机数是说取哈希值后的值是不知道的，不可能真的用随机数，不然就没法验证。填充完后，里面的数有前后依赖关系，是从第一个数依次算出来的，需要求解这个puzzle的时候，按照伪随机数的顺序从数组当中读取一些数，每次读取的位置跟前一个数相关，如图所示。</p> <p><img src="http://mydoc-pics.oss-cn-chengdu.aliyuncs.com/img/e45753d97ca2499abc3e087de105c659.png" alt="img"></p> <ul><li>LiteCoin的好处</li></ul> <p>如果这个数组开的足够大的时候，Miner就是Memory Hard，因为如果不保存数组，那么Mining的计算复杂度会大幅度上升，需要从头计算。所以要想高效地Mining，这个内存区域是需要保存的，有的矿工可能保存一部分内存区的内容，如，只保留数组中奇数位置的元素，这样数组可以少一半，用到偶数位置的数的话，要根据另外一半算一下，计算复杂度会提高一点，但是内存量可以减小一半，叫做time-memory trade off。</p> <p>该设计的核心思想是不能像比特币那样主要进行哈希运算，要增加运算过程中对内存访问的需求，设计一个对ASIC芯片不友好的，普通计算机能参与的。设计的任务更像是普通计算机干的事情，而不是像一个Mining专用的ASIC芯片干的事情，普通计算机内存很大，就要利用这个特性，设计puzzle对资源的需求，特别像是普通计算机对资源的配备比例。</p> <ul><li><p>LiteCoin的缺点</p> <p>LiteCoin的优点是对于矿工Mining的时候是memory hard，缺点是对轻节点来说也是memory hard。设计puzzle的一个原则：difficult to solve,but easy to verify。这个问题在于验证这个puzzle需要的内存区域跟求解需要的区域几乎是一样，轻节点验证的时候也需要保存数组，否则计算复杂度也会大幅度提高。对于scrypt早期计算机的安全领域，不存在轻节点验证这个问题，但对于区块链来说是不行的。</p></li> <li><p>LiteCoin的实践</p> <p>莱特币在真正使用的时候，这个内存区域不敢设置的太大，比如说设一个1G的数组，这对于计算机来说是不大的，但是如果是一个手机上的app，1G的内存可能就太大了。因为这个原因，实际莱特币在使用的时候，这个数组只有128Ks，连1M都不到，就是为了照顾轻节点。</p> <p>当初莱特币在发行的时候，目标不仅仅是ASIC resistance，还是GPU resistance，就是Mining最好连GPU都不要用，都用普通的CPU Mining就行了。结果后来就出现GPU Mining的，再后来就出现用ASIC芯片Mining的，实践证明莱特币要求的128k内存不足以对ASIC芯片的生产和设计带来实际上的障碍。从这一点来说，莱特币的设计目标没有达到，但是早期宣传的设计目标对于解决能启动问题是很有帮助的。任何一个加密货币，都存在能启动问题，包括比特币，一开始的时候，没有人知道这个加密货币，发行一个货币，没有人参与，这是一个问题，对于基于工作量证明的加密货币来说，Mining人太少是不安全的，发动恶意攻击难度太低。</p> <p>比特币早期也是不安全的，当时如果想对比特币发动恶意攻击是很容易的。比特币解决能启动的问题是一个循坏迭代的过程，中本聪宣传的多了，对比特币感兴趣的人就多了，参与Mining人就多了，变得更安全，价值也提高了；然后对比特币感兴趣的人就更多了，Mining的人也更多了，然后比特币变得更安全了，价值就更进一步提高了，形成一个良性循坏。</p> <p>莱特币虽然没有达到当初的设计目标，但是他早期的宣传：更民主、让更多人参与的理念对于聚集人气来说是很重要的。所以莱特币一直到现在也是一个比较主流的加密货币，除了这个Mining Puzzle之外，莱特币跟比特币的另一个区别是来特比的出块速度是比特币的4倍，他的出块间隔是2min30s，而不是10min，除此之外，这两种加密货币基本上是一样的。</p></li></ul></li></ul> <h3 id="以太坊的工作量证明"><a href="#以太坊的工作量证明" class="header-anchor">#</a> 以太坊的工作量证明</h3> <ul><li><p>Memory hard mining puzzle</p> <p>以太坊也是用一种Memory hard mining puzzle，但是在设计上，跟莱特币有很大的不同。以太坊用的是两个数据集，一大一小，小的是16M cache，大的数据集是一个1G dataset,DAG，这1G的数据集是从16M的cache生成出来的，设计成一大一小的两个数据集呢，就是为了便于验证。轻节点只要保存16M cache就行了，只有需要挖矿的矿工才需要保存1G的dataset。</p></li> <li><p>基本思想</p> <p>Cache的生成方式跟LiteCoin中数组的生成方式是比较类似的，首先从一个种子节点seed，进行一些运算，算出数组的第一个元素，然后依次取哈希，第一个元素取哈希得到第二个元素，第二个元素取哈希得到第三个元素，依此类推，把这个数组从前往后，填充一些伪随机数得到一个cache。然后生成一个更大的数组DAG，大数组要比小数组大得多，DAG的每个元素都是从cache里按照伪随机数的顺序读取一些元素，方法和刚才讲的莱特币里面求解puzzle的过程类似。第一次读取A位置的元素，读取完之后，对当前的哈希值进行一些更新迭代，算出下一个要读取的位置，比如说B这个位置，然后把B位置的数再进行一些哈希值的更新，算出C这个位置，那么从这个cache里面这么来回读，一共读256次，读256个数，最后算出来一个数放在大的dataset的第一个元素，然后第二个元素也是一样的，dataset的每个元素都是从这个cache里面按照伪随机数的顺序，不断进行迭代更新，最后得到一个值存在里面，然后求解puzzle的时候，用的是大数据集中的数，这个cache是不用的，按照伪随机数的顺序在大的数据集中读取128个数，就是一开始的时候根据区块的块头，包括里面的nonce值算出一个初始的哈希，根据这个哈希，映射到大数据集里面的某个位置，把这个数读取出来，然后进行一些运算，算出下一个要读取的位置，比如说又在大数据集里面的另一个位置，又把这个数读取出来。这里有一个区别：他每次读取的时候除了计算出这个元素的位置之外，还要把相邻元素（该元素的下一个元素）也要读取出来，这个例子当中每次读取的时候是读取两个相邻元素，这样循环64次，每次读两个元素，所以一共是符合难度要求128个数。最后算出一个哈希值来，跟挖矿难度的目标域值比较是不是符合难度要求，如果不是，把Block Header 里面的Nonce替换一下，换另外一个Nonce，因为换了Nonce之后，第一次算的那个哈希值就变了，然后重复这个过程，再去比较。</p></li> <li><p>ethash算法伪代码</p> <ul><li><p>生成16M cache</p> <div class="language-go extra-class"><pre class="language-go"><code>def <span class="token function">mkcache</span><span class="token punctuation">(</span>cache_size<span class="token punctuation">,</span>seed<span class="token punctuation">)</span><span class="token punctuation">:</span>
    o <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token function">hash</span><span class="token punctuation">(</span>seed<span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i in <span class="token keyword">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>che_size<span class="token punctuation">)</span><span class="token punctuation">:</span>
        o<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>o<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
</code></pre></div><p>cache中每个元素都是64个字节的哈希值，生成的方法与莱特币类似（第一个元素是Seed的哈希，后面每个元素是前一个的哈希），哈希的内容每隔3万个区块会变化一次，Seed每隔3万个区块会发生变化，然后重新生成cache中的内容，同时cache的容量要增加原始大小的1/128，也就是16M的1/128=128K。</p></li></ul></li></ul> <div style="height:50px;width:200px;text-align:center;font-size:32px;color:#3d3d3d;background-color:#BFA;line-height:50px;border-radius:10px;">停更中……</div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">3 天前</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/about.html" class="prev">
        关于
      </a></span> <span class="next"><a href="/blockchain/ETH/部署以太坊私链.html">
        搭建以太坊私链
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d06c6709.js" defer></script><script src="/assets/js/2.58244656.js" defer></script><script src="/assets/js/1.6ba70183.js" defer></script><script src="/assets/js/24.f6864778.js" defer></script>
  </body>
</html>
